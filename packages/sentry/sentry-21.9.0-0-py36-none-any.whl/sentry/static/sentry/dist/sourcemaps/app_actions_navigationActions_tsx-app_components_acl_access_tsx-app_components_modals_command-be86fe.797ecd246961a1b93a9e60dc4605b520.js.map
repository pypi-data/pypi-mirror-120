{"version":3,"file":"chunks/app_actions_navigationActions_tsx-app_components_acl_access_tsx-app_components_modals_command-be86fe.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actions/navigationActions.tsx","webpack:///./app/actions/organizationsActions.tsx","webpack:///./app/actions/projectActions.tsx","webpack:///./app/actions/teamActions.tsx","webpack:///./app/components/acl/access.tsx","webpack:///./app/components/modals/commandPalette.tsx","webpack:///./app/data/forms/accountEmails.tsx","webpack:///./app/stores/organizationsStore.tsx","webpack:///./app/stores/projectsStore.tsx","webpack:///./app/utils/parseLinkHeader.tsx","webpack:///./app/utils/projects.tsx","webpack:///./app/utils/useApi.tsx","webpack:///./app/utils/withApi.tsx","webpack:///./app/utils/withProjects.tsx"],"sourcesContent":["import Reflux from 'reflux';\n\nexport default Reflux.createActions(['setLastRoute']);\n","import Reflux from 'reflux';\n\nconst OrganizationsActions = Reflux.createActions([\n  'update',\n  'setActive',\n  'changeSlug',\n  'remove',\n  'removeSuccess',\n  'removeError',\n]);\n\nexport default OrganizationsActions;\n","import Reflux from 'reflux';\n\nexport default Reflux.createActions([\n  'addTeam',\n  'addTeamError',\n  'addTeamSuccess',\n  'changeSlug',\n  'createSuccess',\n  'loadProjects',\n  'loadStats',\n  'loadStatsError',\n  'loadStatsForProjectSuccess',\n  'loadStatsSuccess',\n  'removeProject',\n  'removeProjectError',\n  'removeProjectSuccess',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'reset',\n  'setActive',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n","import Reflux from 'reflux';\n\nconst TeamActions = Reflux.createActions([\n  'createTeam',\n  'createTeamError',\n  'createTeamSuccess',\n  'fetchAll',\n  'fetchAllError',\n  'fetchAllSuccess',\n  'fetchDetails',\n  'fetchDetailsError',\n  'fetchDetailsSuccess',\n  'loadTeams',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n\nexport default TeamActions;\n","import * as React from 'react';\n\nimport Alert from 'app/components/alert';\nimport {IconInfo} from 'app/icons';\nimport {t} from 'app/locale';\nimport {Config, Organization, Scope} from 'app/types';\nimport {isRenderFunc} from 'app/utils/isRenderFunc';\nimport withConfig from 'app/utils/withConfig';\nimport withOrganization from 'app/utils/withOrganization';\n\nconst DEFAULT_NO_ACCESS_MESSAGE = (\n  <Alert type=\"error\" icon={<IconInfo size=\"md\" />}>\n    {t('You do not have sufficient permissions to access this.')}\n  </Alert>\n);\n\n// Props that function children will get.\nexport type ChildRenderProps = {\n  hasAccess: boolean;\n  hasSuperuser: boolean;\n};\n\ntype ChildFunction = (props: ChildRenderProps) => React.ReactNode;\n\ntype DefaultProps = {\n  /**\n   * Should the component require all access levels or just one or more.\n   */\n  requireAll?: boolean;\n\n  /**\n   * Requires superuser\n   */\n  isSuperuser?: boolean;\n\n  /**\n   * Custom renderer function for \"no access\" message OR `true` to use\n   * default message. `false` will suppress message.\n   */\n  renderNoAccessMessage: ChildFunction | boolean;\n\n  /**\n   * List of required access levels\n   */\n  access: Scope[];\n};\n\nconst defaultProps: DefaultProps = {\n  renderNoAccessMessage: false,\n  isSuperuser: false,\n  requireAll: true,\n  access: [],\n};\n\ntype Props = {\n  /**\n   * Current Organization\n   */\n  organization: Organization;\n\n  /**\n   * Configuration from ConfigStore\n   */\n  config: Config;\n\n  /**\n   * Children can be a node or a function as child.\n   */\n  children?: React.ReactNode | ChildFunction;\n} & Partial<DefaultProps>;\n\n/**\n * Component to handle access restrictions.\n */\nclass Access extends React.Component<Props> {\n  static defaultProps = defaultProps;\n\n  render() {\n    const {\n      organization,\n      config,\n      access,\n      requireAll,\n      isSuperuser,\n      renderNoAccessMessage,\n      children,\n    } = this.props;\n\n    const {access: orgAccess} = organization || {access: []};\n    const method = requireAll ? 'every' : 'some';\n\n    const hasAccess = !access || access[method](acc => orgAccess.includes(acc));\n    const hasSuperuser = !!(config.user && config.user.isSuperuser);\n\n    const renderProps: ChildRenderProps = {\n      hasAccess,\n      hasSuperuser,\n    };\n\n    const render = hasAccess && (!isSuperuser || hasSuperuser);\n\n    if (!render && typeof renderNoAccessMessage === 'function') {\n      return renderNoAccessMessage(renderProps);\n    } else if (!render && renderNoAccessMessage) {\n      return DEFAULT_NO_ACCESS_MESSAGE;\n    }\n\n    if (isRenderFunc<ChildFunction>(children)) {\n      return children(renderProps);\n    }\n\n    return render ? children : null;\n  }\n}\n\nexport default withOrganization(withConfig(Access));\n","import {Component} from 'react';\nimport {ClassNames, css, withTheme} from '@emotion/react';\nimport styled from '@emotion/styled';\n\nimport {ModalRenderProps} from 'app/actionCreators/modal';\nimport Search from 'app/components/search';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {analytics} from 'app/utils/analytics';\nimport {Theme} from 'app/utils/theme';\nimport Input from 'app/views/settings/components/forms/controls/input';\n\ntype Props = ModalRenderProps & {\n  theme: Theme;\n};\n\nclass CommandPalette extends Component<Props> {\n  componentDidMount() {\n    analytics('omnisearch.open', {});\n  }\n\n  render() {\n    const {theme, Body} = this.props;\n\n    return (\n      <Body>\n        <ClassNames>\n          {({css: injectedCss}) => (\n            <Search\n              entryPoint=\"command_palette\"\n              minSearch={1}\n              maxResults={10}\n              dropdownStyle={injectedCss`\n                width: 100%;\n                border: transparent;\n                border-top-left-radius: 0;\n                border-top-right-radius: 0;\n                position: initial;\n                box-shadow: none;\n                border-top: 1px solid ${theme.border};\n              `}\n              renderInput={({getInputProps}) => (\n                <InputWrapper>\n                  <StyledInput\n                    autoFocus\n                    {...getInputProps({\n                      type: 'text',\n                      placeholder: t('Search for projects, teams, settings, etc...'),\n                    })}\n                  />\n                </InputWrapper>\n              )}\n            />\n          )}\n        </ClassNames>\n      </Body>\n    );\n  }\n}\n\nexport default withTheme(CommandPalette);\n\nexport const modalCss = css`\n  [role='document'] {\n    padding: 0;\n  }\n`;\n\nconst InputWrapper = styled('div')`\n  padding: ${space(0.25)};\n`;\n\nconst StyledInput = styled(Input)`\n  width: 100%;\n  padding: ${space(1)};\n  border-radius: 8px;\n\n  outline: none;\n  border: none;\n  box-shadow: none;\n\n  :focus,\n  :active,\n  :hover {\n    outline: none;\n    border: none;\n    box-shadow: none;\n  }\n`;\n","import {JsonFormObject} from 'app/views/settings/components/forms/type';\n\n// Export route to make these forms searchable by label/help\nexport const route = '/settings/account/emails/';\n\nconst formGroups: JsonFormObject[] = [\n  {\n    // Form \"section\"/\"panel\"\n    title: 'Add Secondary Emails',\n    fields: [\n      {\n        name: 'email',\n        type: 'string',\n\n        // additional data/props that is related to rendering of form field rather than data\n        label: 'Additional Email',\n        placeholder: 'e.g. secondary@example.com',\n        help: 'Designate an alternative email for this account',\n        showReturnButton: true,\n      },\n    ],\n  },\n];\n\nexport default formGroups;\n","import Reflux from 'reflux';\n\nimport OrganizationsActions from 'app/actions/organizationsActions';\nimport {Organization} from 'app/types';\n\ntype OrganizationsStoreInterface = {\n  state: Organization[];\n  loaded: boolean;\n\n  onUpdate: (org: Organization) => void;\n  onChangeSlug: (prev: Organization, next: Organization) => void;\n  onRemoveSuccess: (slug: string) => void;\n  get: (slug: string) => Organization | undefined;\n  getAll: () => Organization[];\n  remove: (slug: string) => void;\n  add: (item: Organization) => void;\n  load: (items: Organization[]) => void;\n};\n\nconst organizationsStoreConfig: Reflux.StoreDefinition & OrganizationsStoreInterface = {\n  listenables: [OrganizationsActions],\n\n  state: [],\n  loaded: false,\n\n  // So we can use Reflux.connect in a component mixin\n  getInitialState() {\n    return this.state;\n  },\n\n  init() {\n    this.state = [];\n    this.loaded = false;\n  },\n\n  onUpdate(org: Organization) {\n    this.add(org);\n  },\n\n  onChangeSlug(prev: Organization, next: Organization) {\n    if (prev.slug === next.slug) {\n      return;\n    }\n\n    this.remove(prev.slug);\n    this.add(next);\n  },\n\n  onRemoveSuccess(slug: string) {\n    this.remove(slug);\n  },\n\n  get(slug: Organization['slug']) {\n    return this.state.find((item: Organization) => item.slug === slug);\n  },\n\n  getAll() {\n    return this.state;\n  },\n\n  remove(slug: Organization['slug']) {\n    this.state = this.state.filter(item => slug !== item.slug);\n    this.trigger(this.state);\n  },\n\n  add(item: Organization) {\n    let match = false;\n    this.state.forEach((existing, idx) => {\n      if (existing.id === item.id) {\n        item = {...existing, ...item};\n        this.state[idx] = item;\n        match = true;\n      }\n    });\n    if (!match) {\n      this.state = [...this.state, item];\n    }\n    this.trigger(this.state);\n  },\n\n  load(items: Organization[]) {\n    this.state = items;\n    this.loaded = true;\n    this.trigger(items);\n  },\n};\n\nconst OrganizationsStore = Reflux.createStore(organizationsStoreConfig) as Reflux.Store &\n  OrganizationsStoreInterface;\n\nexport default OrganizationsStore;\n","import Reflux from 'reflux';\n\nimport ProjectActions from 'app/actions/projectActions';\nimport TeamActions from 'app/actions/teamActions';\nimport {Project, Team} from 'app/types';\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\ntype StatsData = Record<string, Project['stats']>;\n\n/**\n * Attributes that need typing but aren't part of the external interface,\n */\ntype Internals = {\n  itemsById: Record<string, Project>;\n  loading: boolean;\n};\n\ntype ProjectsStoreInterface = {\n  init: () => void;\n  reset: () => void;\n  loadInitialData: (projects: Project[]) => void;\n  onStatsLoadSuccess: (data: StatsData) => void;\n  onChangeSlug: (prevSlug: string, newSlug: string) => void;\n  onCreateSuccess: (project: Project) => void;\n  onUpdateSuccess: (data: Partial<Project>) => void;\n  onDeleteTeam: (slug: string) => void;\n  onRemoveTeam: (teamSlug: string, projectSlug: string) => void;\n  onAddTeam: (team: Team, projectSlug: string) => void;\n  removeTeamFromProject: (teamSlug: string, project: Project) => void;\n  getWithTeam: (teamSlug: string) => Project[];\n  getAll: () => Project[];\n  getBySlugs: (slug: string[]) => Project[];\n  getState: (slugs?: string[]) => State;\n  getById: (id?: string) => Project | undefined;\n  getBySlug: (slug?: string) => Project | undefined;\n};\n\nconst storeConfig: Reflux.StoreDefinition & Internals & ProjectsStoreInterface = {\n  itemsById: {},\n  loading: true,\n\n  init() {\n    this.reset();\n\n    this.listenTo(ProjectActions.addTeamSuccess, this.onAddTeam);\n    this.listenTo(ProjectActions.changeSlug, this.onChangeSlug);\n    this.listenTo(ProjectActions.createSuccess, this.onCreateSuccess);\n    this.listenTo(ProjectActions.loadProjects, this.loadInitialData);\n    this.listenTo(ProjectActions.loadStatsSuccess, this.onStatsLoadSuccess);\n    this.listenTo(ProjectActions.removeTeamSuccess, this.onRemoveTeam);\n    this.listenTo(ProjectActions.reset, this.reset);\n    this.listenTo(ProjectActions.updateSuccess, this.onUpdateSuccess);\n\n    this.listenTo(TeamActions.removeTeamSuccess, this.onDeleteTeam);\n  },\n\n  reset() {\n    this.itemsById = {};\n    this.loading = true;\n  },\n\n  loadInitialData(items: Project[]) {\n    this.itemsById = items.reduce((map, project) => {\n      map[project.id] = project;\n      return map;\n    }, {});\n    this.loading = false;\n    this.trigger(new Set(Object.keys(this.itemsById)));\n  },\n\n  onChangeSlug(prevSlug: string, newSlug: string) {\n    const prevProject = this.getBySlug(prevSlug);\n\n    // This shouldn't happen\n    if (!prevProject) {\n      return;\n    }\n\n    const newProject = {\n      ...prevProject,\n      slug: newSlug,\n    };\n\n    this.itemsById = {\n      ...this.itemsById,\n      [newProject.id]: newProject,\n    };\n\n    // Ideally we'd always trigger this.itemsById, but following existing patterns\n    // so we don't break things\n    this.trigger(new Set([prevProject.id]));\n  },\n\n  onCreateSuccess(project: Project) {\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: project,\n    };\n    this.trigger(new Set([project.id]));\n  },\n\n  onUpdateSuccess(data: Partial<Project>) {\n    const project = this.getById(data.id);\n    if (!project) {\n      return;\n    }\n    const newProject = Object.assign({}, project, data);\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: newProject,\n    };\n    this.trigger(new Set([data.id]));\n  },\n\n  onStatsLoadSuccess(data) {\n    const touchedIds: string[] = [];\n    Object.entries(data || {}).forEach(([projectId, stats]) => {\n      if (projectId in this.itemsById) {\n        this.itemsById[projectId].stats = stats;\n        touchedIds.push(projectId);\n      }\n    });\n    this.trigger(new Set(touchedIds));\n  },\n\n  /**\n   * Listener for when a team is completely removed\n   *\n   * @param teamSlug Team Slug\n   */\n  onDeleteTeam(teamSlug: string) {\n    // Look for team in all projects\n    const projectIds = this.getWithTeam(teamSlug).map(projectWithTeam => {\n      this.removeTeamFromProject(teamSlug, projectWithTeam);\n      return projectWithTeam.id;\n    });\n\n    this.trigger(new Set([projectIds]));\n  },\n\n  onRemoveTeam(teamSlug: string, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n    if (!project) {\n      return;\n    }\n\n    this.removeTeamFromProject(teamSlug, project);\n    this.trigger(new Set([project.id]));\n  },\n\n  onAddTeam(team: Team, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n\n    // Don't do anything if we can't find a project\n    if (!project) {\n      return;\n    }\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: [...project.teams, team],\n      },\n    };\n\n    this.trigger(new Set([project.id]));\n  },\n\n  // Internal method, does not trigger\n  removeTeamFromProject(teamSlug: string, project: Project) {\n    const newTeams = project.teams.filter(({slug}) => slug !== teamSlug);\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: newTeams,\n      },\n    };\n  },\n\n  /**\n   * Returns a list of projects that has the specified team\n   *\n   * @param {String} teamSlug Slug of team to find in projects\n   */\n  getWithTeam(teamSlug: string) {\n    return this.getAll().filter(({teams}) => teams.find(({slug}) => slug === teamSlug));\n  },\n\n  getAll() {\n    return Object.values(this.itemsById).sort((a: Project, b: Project) => {\n      if (a.slug > b.slug) {\n        return 1;\n      }\n      if (a.slug < b.slug) {\n        return -1;\n      }\n      return 0;\n    });\n  },\n\n  getById(id) {\n    return this.getAll().find(project => project.id === id);\n  },\n\n  getBySlug(slug) {\n    return this.getAll().find(project => project.slug === slug);\n  },\n\n  getBySlugs(slugs: string[]) {\n    return this.getAll().filter(project => slugs.includes(project.slug));\n  },\n\n  getState(slugs?: string[]): State {\n    return {\n      projects: slugs ? this.getBySlugs(slugs) : this.getAll(),\n      loading: this.loading,\n    };\n  },\n};\n\nconst ProjectsStore = Reflux.createStore(storeConfig) as Reflux.Store &\n  ProjectsStoreInterface;\n\nexport default ProjectsStore;\n","type Result = Record<string, {href: string; results: boolean | null; cursor: string}>;\n\nexport default function parseLinkHeader(header: string | null): Result {\n  if (header === null || header === '') {\n    return {};\n  }\n\n  const headerValues = header.split(',');\n  const links = {};\n\n  headerValues.forEach(val => {\n    const match =\n      /<([^>]+)>; rel=\"([^\"]+)\"(?:; results=\"([^\"]+)\")?(?:; cursor=\"([^\"]+)\")?/g.exec(\n        val\n      );\n    const hasResults = match![3] === 'true' ? true : match![3] === 'false' ? false : null;\n\n    links[match![2]] = {\n      href: match![1],\n      results: hasResults,\n      cursor: match![4],\n    };\n  });\n\n  return links;\n}\n","import * as React from 'react';\nimport memoize from 'lodash/memoize';\nimport partition from 'lodash/partition';\nimport uniqBy from 'lodash/uniqBy';\n\nimport ProjectActions from 'app/actions/projectActions';\nimport {Client} from 'app/api';\nimport ProjectsStore from 'app/stores/projectsStore';\nimport {AvatarProject, Project} from 'app/types';\nimport {defined} from 'app/utils';\nimport parseLinkHeader from 'app/utils/parseLinkHeader';\nimport RequestError from 'app/utils/requestError/requestError';\nimport withApi from 'app/utils/withApi';\nimport withProjects from 'app/utils/withProjects';\n\ntype ProjectPlaceholder = AvatarProject;\n\ntype State = {\n  /**\n   * Projects from API\n   */\n  fetchedProjects: Project[] | ProjectPlaceholder[];\n\n  /**\n   * Projects fetched from store\n   */\n  projectsFromStore: Project[];\n\n  /**\n   * Reflects whether or not the initial fetch for the requested projects\n   * was fulfilled\n   */\n  initiallyLoaded: boolean;\n\n  /**\n   * This is state for when fetching data from API\n   */\n  fetching: boolean;\n\n  /**\n   * This is set when we fail to find some slugs from both store and API\n   */\n  isIncomplete: null | boolean;\n\n  /**\n   * Project results (from API) are paginated and there are more projects\n   * that are not in the initial queryset\n   */\n  hasMore: null | boolean;\n  prevSearch: null | string;\n  nextCursor?: null | string;\n\n  /**\n   * The error that occurred if fetching failed\n   */\n  fetchError: null | RequestError;\n};\n\nexport type RenderProps = {\n  /**\n   * We want to make sure that at the minimum, we return a list of objects with only `slug`\n   * while we load actual project data\n   */\n  projects: Project[] | ProjectPlaceholder[];\n\n  /**\n   * Calls API and searches for project, accepts a callback function with signature:\n   * fn(searchTerm, {append: bool})\n   */\n  onSearch: (searchTerm: string, {append: boolean}) => void;\n} & Pick<\n  State,\n  'isIncomplete' | 'fetching' | 'hasMore' | 'initiallyLoaded' | 'fetchError'\n>;\ntype RenderFunc = (props: RenderProps) => React.ReactNode;\n\ntype DefaultProps = {\n  /**\n   * If slugs is passed, forward placeholder objects with slugs while fetching\n   */\n  passthroughPlaceholderProject?: boolean;\n};\n\ntype Props = {\n  api: Client;\n\n  /**\n   * Organization slug\n   */\n  orgId: string;\n\n  /**\n   * List of projects that have we already have summaries for (i.e. from store)\n   */\n  projects: Project[];\n\n  /**\n   * List of slugs to look for summaries for, this can be from `props.projects`,\n   * otherwise fetch from API\n   */\n  slugs?: string[];\n\n  /**\n   * Number of projects to return when not using `props.slugs`\n   */\n  limit?: number;\n\n  /**\n   * Whether to fetch all the projects in the organization of which the user\n   * has access to\n   * */\n  allProjects?: boolean;\n\n  children: RenderFunc;\n} & DefaultProps;\n\n/**\n * This is a utility component that should be used to fetch an organization's projects (summary).\n * It can either fetch explicit projects (e.g. via slug) or a paginated list of projects.\n * These will be passed down to the render prop (`children`).\n *\n * The legacy way of handling this is that `ProjectSummary[]` is expected to be included in an\n * `Organization` as well as being saved to `ProjectsStore`.\n */\nclass Projects extends React.Component<Props, State> {\n  static defaultProps: DefaultProps = {\n    passthroughPlaceholderProject: true,\n  };\n\n  state: State = {\n    fetchedProjects: [],\n    projectsFromStore: [],\n    initiallyLoaded: false,\n    fetching: false,\n    isIncomplete: null,\n    hasMore: null,\n    prevSearch: null,\n    nextCursor: null,\n    fetchError: null,\n  };\n\n  componentDidMount() {\n    const {slugs} = this.props;\n\n    if (slugs && !!slugs.length) {\n      this.loadSpecificProjects();\n    } else {\n      this.loadAllProjects();\n    }\n  }\n\n  /**\n   * List of projects that need to be fetched via API\n   */\n  fetchQueue: Set<string> = new Set();\n\n  /**\n   * Memoized function that returns a `Map<project.slug, project>`\n   */\n  getProjectsMap: (projects: Project[]) => Map<string, Project> = memoize(\n    projects => new Map(projects.map(project => [project.slug, project]))\n  );\n\n  /**\n   * When `props.slugs` is included, identifies what projects we already\n   * have summaries for and what projects need to be fetched from API\n   */\n  loadSpecificProjects = () => {\n    const {slugs, projects} = this.props;\n\n    const projectsMap = this.getProjectsMap(projects);\n\n    // Split slugs into projects that are in store and not in store\n    // (so we can request projects not in store)\n    const [inStore, notInStore] = partition(slugs, slug => projectsMap.has(slug));\n\n    // Get the actual summaries of projects that are in store\n    const projectsFromStore = inStore.map(slug => projectsMap.get(slug)).filter(defined);\n\n    // Add to queue\n    notInStore.forEach(slug => this.fetchQueue.add(slug));\n\n    this.setState({\n      // placeholders for projects we need to fetch\n      fetchedProjects: notInStore.map(slug => ({slug})),\n      // set initiallyLoaded if any projects were fetched from store\n      initiallyLoaded: !!inStore.length,\n      projectsFromStore,\n    });\n\n    if (!notInStore.length) {\n      return;\n    }\n\n    this.fetchSpecificProjects();\n  };\n\n  /**\n   * These will fetch projects via API (using project slug) provided by `this.fetchQueue`\n   */\n  fetchSpecificProjects = async () => {\n    const {api, orgId, passthroughPlaceholderProject} = this.props;\n\n    if (!this.fetchQueue.size) {\n      return;\n    }\n\n    this.setState({\n      fetching: true,\n    });\n\n    let projects: Project[] = [];\n    let fetchError = null;\n\n    try {\n      const {results} = await fetchProjects(api, orgId, {\n        slugs: Array.from(this.fetchQueue),\n      });\n      projects = results;\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n      fetchError = err;\n    }\n\n    const projectsMap = this.getProjectsMap(projects);\n\n    // For each item in the fetch queue, lookup the project object and in the case\n    // where something wrong has happened and we were unable to get project summary from\n    // the server, just fill in with an object with only the slug\n    const projectsOrPlaceholder: Project[] | ProjectPlaceholder[] = Array.from(\n      this.fetchQueue\n    )\n      .map(slug =>\n        projectsMap.has(slug)\n          ? projectsMap.get(slug)\n          : !!passthroughPlaceholderProject\n          ? {slug}\n          : null\n      )\n      .filter(defined);\n\n    this.setState({\n      fetchedProjects: projectsOrPlaceholder,\n      isIncomplete: this.fetchQueue.size !== projects.length,\n      initiallyLoaded: true,\n      fetching: false,\n      fetchError,\n    });\n\n    this.fetchQueue.clear();\n  };\n\n  /**\n   * If `props.slugs` is not provided, request from API a list of paginated project summaries\n   * that are in `prop.orgId`.\n   *\n   * Provide render prop with results as well as `hasMore` to indicate there are more results.\n   * Downstream consumers should use this to notify users so that they can e.g. narrow down\n   * results using search\n   */\n  loadAllProjects = async () => {\n    const {api, orgId, limit, allProjects} = this.props;\n\n    this.setState({\n      fetching: true,\n    });\n\n    try {\n      const {results, hasMore, nextCursor} = await fetchProjects(api, orgId, {\n        limit,\n        allProjects,\n      });\n\n      this.setState({\n        fetching: false,\n        fetchedProjects: results,\n        initiallyLoaded: true,\n        hasMore,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      this.setState({\n        fetching: false,\n        fetchedProjects: [],\n        initiallyLoaded: true,\n        fetchError: err,\n      });\n    }\n  };\n\n  /**\n   * This is an action provided to consumers for them to update the current projects\n   * result set using a simple search query. You can allow the new results to either\n   * be appended or replace the existing results.\n   *\n   * @param {String} search The search term to use\n   * @param {Object} options Options object\n   * @param {Boolean} options.append Results should be appended to existing list (otherwise, will replace)\n   */\n  handleSearch = async (search: string, {append}: {append?: boolean} = {}) => {\n    const {api, orgId, limit} = this.props;\n    const {prevSearch} = this.state;\n    const cursor = this.state.nextCursor;\n\n    this.setState({fetching: true});\n\n    try {\n      const {results, hasMore, nextCursor} = await fetchProjects(api, orgId, {\n        search,\n        limit,\n        prevSearch,\n        cursor,\n      });\n\n      this.setState((state: State) => {\n        let fetchedProjects;\n        if (append) {\n          // Remove duplicates\n          fetchedProjects = uniqBy(\n            [...state.fetchedProjects, ...results],\n            ({slug}) => slug\n          );\n        } else {\n          fetchedProjects = results;\n        }\n        return {\n          fetchedProjects,\n          hasMore,\n          fetching: false,\n          prevSearch: search,\n          nextCursor,\n        };\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      this.setState({\n        fetching: false,\n        fetchError: err,\n      });\n    }\n  };\n\n  render() {\n    const {slugs, children} = this.props;\n\n    const renderProps = {\n      // We want to make sure that at the minimum, we return a list of objects with only `slug`\n      // while we load actual project data\n      projects: this.state.initiallyLoaded\n        ? [...this.state.fetchedProjects, ...this.state.projectsFromStore]\n        : (slugs && slugs.map(slug => ({slug}))) || [],\n\n      // This is set when we fail to find some slugs from both store and API\n      isIncomplete: this.state.isIncomplete,\n\n      // This is state for when fetching data from API\n      fetching: this.state.fetching,\n\n      // Project results (from API) are paginated and there are more projects\n      // that are not in the initial queryset\n      hasMore: this.state.hasMore,\n\n      // Calls API and searches for project, accepts a callback function with signature:\n      //\n      // fn(searchTerm, {append: bool})\n      onSearch: this.handleSearch,\n\n      // Reflects whether or not the initial fetch for the requested projects\n      // was fulfilled\n      initiallyLoaded: this.state.initiallyLoaded,\n\n      // The error that occurred if fetching failed\n      fetchError: this.state.fetchError,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default withProjects(withApi(Projects));\n\ntype FetchProjectsOptions = {\n  slugs?: string[];\n  cursor?: State['nextCursor'];\n  search?: State['prevSearch'];\n  prevSearch?: State['prevSearch'];\n} & Pick<Props, 'limit' | 'allProjects'>;\n\nasync function fetchProjects(\n  api: Client,\n  orgId: string,\n  {slugs, search, limit, prevSearch, cursor, allProjects}: FetchProjectsOptions = {}\n) {\n  const query: {\n    query?: string;\n    cursor?: typeof cursor;\n    per_page?: number;\n    all_projects?: number;\n    collapse: string[];\n  } = {\n    // Never return latestDeploys project property from api\n    collapse: ['latestDeploys'],\n  };\n\n  if (slugs && slugs.length) {\n    query.query = slugs.map(slug => `slug:${slug}`).join(' ');\n  }\n\n  if (search) {\n    query.query = `${query.query ? `${query.query} ` : ''}${search}`;\n  }\n\n  if (((!prevSearch && !search) || prevSearch === search) && cursor) {\n    query.cursor = cursor;\n  }\n\n  // \"0\" shouldn't be a valid value, so this check is fine\n  if (limit) {\n    query.per_page = limit;\n  }\n\n  if (allProjects) {\n    const {loading, projects} = ProjectsStore.getState();\n    // If the projects store is loaded then return all projects from the store\n    if (!loading) {\n      return {\n        results: projects,\n        hasMore: false,\n      };\n    }\n    // Otherwise mark the query to fetch all projects from the API\n    query.all_projects = 1;\n  }\n\n  let hasMore: null | boolean = false;\n  let nextCursor: null | string = null;\n  const [data, , resp] = await api.requestPromise(`/organizations/${orgId}/projects/`, {\n    includeAllArgs: true,\n    query,\n  });\n\n  const pageLinks = resp?.getResponseHeader('Link');\n  if (pageLinks) {\n    const paginationObject = parseLinkHeader(pageLinks);\n    hasMore =\n      paginationObject &&\n      (paginationObject.next.results || paginationObject.previous.results);\n    nextCursor = paginationObject.next.cursor;\n  }\n\n  // populate the projects store if all projects were fetched\n  if (allProjects) {\n    ProjectActions.loadProjects(data);\n  }\n\n  return {\n    results: data,\n    hasMore,\n    nextCursor,\n  };\n}\n","import {useEffect, useRef} from 'react';\n\nimport {Client} from 'app/api';\n\ntype Options = {\n  /**\n   * Enabling this option will disable clearing in-flight requests when the\n   * component is unmounted.\n   *\n   * This may be useful in situations where your component needs to finish up\n   * somewhere the client was passed into some type of action creator and the\n   * component is unmounted.\n   */\n  persistInFlight?: boolean;\n  /**\n   * An existing API client may be provided.\n   *\n   * This is a continent way to re-use clients and still inherit the\n   * persistInFlight configuration.\n   */\n  api?: Client;\n};\n\n/**\n * Returns an API client that will have it's requests canceled when the owning\n * React component is unmounted (may be disabled via options).\n */\nfunction useApi({persistInFlight, api: providedApi}: Options = {}) {\n  const localApi = useRef<Client>();\n\n  // Lazily construct the client if we weren't provided with one\n  if (localApi.current === undefined && providedApi === undefined) {\n    localApi.current = new Client();\n  }\n\n  // Use the provided client if available\n  const api = providedApi ?? localApi.current!;\n\n  function handleCleanup() {\n    !persistInFlight && api.clear();\n  }\n\n  useEffect(() => handleCleanup, []);\n\n  return api;\n}\n\nexport default useApi;\n","import {Client} from 'app/api';\nimport getDisplayName from 'app/utils/getDisplayName';\nimport useApi from 'app/utils/useApi';\n\ntype InjectedApiProps = {\n  api: Client;\n};\n\ntype WrappedProps<P> = Omit<P, keyof InjectedApiProps> & Partial<InjectedApiProps>;\n\n/**\n * XXX: Prefer useApi if you are wrapping a Function Component!\n *\n * React Higher-Order Component (HoC) that provides \"api\" client when mounted,\n * and clears API requests when component is unmounted.\n *\n * If an `api` prop is provided when the component is invoked it will be passed\n * through.\n */\nconst withApi = <P extends InjectedApiProps>(\n  WrappedComponent: React.ComponentType<P>,\n  options: Parameters<typeof useApi>[0] = {}\n) => {\n  const WithApi: React.FC<WrappedProps<P>> = ({api: propsApi, ...props}) => {\n    const api = useApi({api: propsApi, ...options});\n\n    return <WrappedComponent {...(props as P)} api={api} />;\n  };\n\n  WithApi.displayName = `withApi(${getDisplayName(WrappedComponent)})`;\n\n  return WithApi;\n};\n\nexport default withApi;\n","import * as React from 'react';\n\nimport ProjectsStore from 'app/stores/projectsStore';\nimport {Project} from 'app/types';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedProjectsProps = {\n  projects: Project[];\n  loadingProjects?: boolean;\n};\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\n/**\n * Higher order component that uses ProjectsStore and provides a list of projects\n */\nfunction withProjects<P extends InjectedProjectsProps>(\n  WrappedComponent: React.ComponentType<P>\n) {\n  class WithProjects extends React.Component<\n    Omit<P, keyof InjectedProjectsProps> & Partial<InjectedProjectsProps>,\n    State\n  > {\n    static displayName = `withProjects(${getDisplayName(WrappedComponent)})`;\n\n    state: State = ProjectsStore.getState();\n\n    componentWillUnmount() {\n      this.unsubscribe();\n    }\n\n    unsubscribe = ProjectsStore.listen(\n      () => this.setState(ProjectsStore.getState()),\n      undefined\n    );\n\n    render() {\n      return (\n        <WrappedComponent\n          {...(this.props as P)}\n          projects={this.state.projects}\n          loadingProjects={this.state.loading}\n        />\n      );\n    }\n  }\n\n  return WithProjects;\n}\n\nexport default withProjects;\n"],"names":["Reflux","DEFAULT_NO_ACCESS_MESSAGE","type","icon","size","t","Access","React","render","organization","config","access","requireAll","isSuperuser","renderNoAccessMessage","children","this","props","orgAccess","hasAccess","acc","includes","hasSuperuser","user","renderProps","isRenderFunc","withOrganization","withConfig","CommandPalette","Component","componentDidMount","analytics","theme","Body","css","injectedCss","entryPoint","minSearch","maxResults","dropdownStyle","border","renderInput","getInputProps","InputWrapper","StyledInput","autoFocus","placeholder","withTheme","modalCss","space","Input","route","title","fields","name","label","help","showReturnButton","organizationsStoreConfig","listenables","OrganizationsActions","state","loaded","getInitialState","init","onUpdate","org","add","onChangeSlug","prev","next","slug","remove","onRemoveSuccess","get","find","item","getAll","filter","trigger","match","forEach","existing","idx","id","load","items","storeConfig","itemsById","loading","reset","listenTo","ProjectActions","onAddTeam","onCreateSuccess","loadInitialData","onStatsLoadSuccess","onRemoveTeam","onUpdateSuccess","TeamActions","onDeleteTeam","reduce","map","project","Set","Object","keys","prevSlug","newSlug","prevProject","getBySlug","newProject","data","getById","assign","touchedIds","entries","projectId","stats","push","teamSlug","projectIds","getWithTeam","projectWithTeam","removeTeamFromProject","projectSlug","team","teams","newTeams","values","sort","a","b","getBySlugs","slugs","getState","projects","parseLinkHeader","header","headerValues","split","links","val","exec","hasResults","href","results","cursor","Projects","fetchedProjects","projectsFromStore","initiallyLoaded","fetching","isIncomplete","hasMore","prevSearch","nextCursor","fetchError","memoize","Map","projectsMap","getProjectsMap","inStore","notInStore","partition","has","defined","fetchQueue","setState","length","fetchSpecificProjects","async","api","orgId","passthroughPlaceholderProject","fetchProjects","Array","from","err","console","error","projectsOrPlaceholder","clear","limit","allProjects","search","append","uniqBy","loadSpecificProjects","loadAllProjects","onSearch","handleSearch","withProjects","withApi","query","collapse","join","per_page","ProjectsStore","all_projects","resp","requestPromise","includeAllArgs","pageLinks","getResponseHeader","paginationObject","previous","persistInFlight","providedApi","localApi","useRef","undefined","current","Client","handleCleanup","useEffect","WrappedComponent","options","WithApi","propsApi","useApi","displayName","getDisplayName","WithProjects","componentWillUnmount","unsubscribe","loadingProjects"],"sourceRoot":""}