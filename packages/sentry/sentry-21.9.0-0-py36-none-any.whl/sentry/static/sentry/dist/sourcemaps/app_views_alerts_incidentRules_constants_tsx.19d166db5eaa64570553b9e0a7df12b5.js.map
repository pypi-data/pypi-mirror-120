{"version":3,"file":"chunks/app_views_alerts_incidentRules_constants_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/views/alerts/incidentRules/constants.tsx","webpack:///./app/views/alerts/utils/getIncidentDiscoverUrl.tsx","webpack:///./app/views/alerts/incidentRules/presets.tsx","webpack:///./app/views/alerts/incidentRules/types.tsx","webpack:///./app/views/alerts/types.tsx","webpack:///./app/views/alerts/utils/index.tsx"],"sourcesContent":["import EventView from 'app/utils/discover/eventView';\nimport {AggregationKey, LooseFieldKey} from 'app/utils/discover/fields';\nimport {WEB_VITAL_DETAILS} from 'app/utils/performance/vitals/constants';\nimport {\n  AlertRuleThresholdType,\n  Dataset,\n  Datasource,\n  EventTypes,\n  Trigger,\n  UnsavedIncidentRule,\n} from 'app/views/alerts/incidentRules/types';\nimport {\n  DATA_SOURCE_TO_SET_AND_EVENT_TYPES,\n  getQueryDatasource,\n} from 'app/views/alerts/utils';\nimport {AlertType, WizardRuleTemplate} from 'app/views/alerts/wizard/options';\n\nexport const DEFAULT_AGGREGATE = 'count()';\nexport const DEFAULT_TRANSACTION_AGGREGATE = 'p95(transaction.duration)';\n\nexport const DATASET_EVENT_TYPE_FILTERS = {\n  [Dataset.ERRORS]: 'event.type:error',\n  [Dataset.TRANSACTIONS]: 'event.type:transaction',\n} as const;\n\nexport const DATASOURCE_EVENT_TYPE_FILTERS = {\n  [Datasource.ERROR_DEFAULT]: '(event.type:error OR event.type:default)',\n  [Datasource.ERROR]: 'event.type:error',\n  [Datasource.DEFAULT]: 'event.type:default',\n  [Datasource.TRANSACTION]: 'event.type:transaction',\n} as const;\n\nexport type OptionConfig = {\n  aggregations: AggregationKey[];\n  fields: LooseFieldKey[];\n  measurementKeys?: string[];\n};\n\n/**\n * Allowed error aggregations for alerts\n */\nexport const errorFieldConfig: OptionConfig = {\n  aggregations: ['count', 'count_unique'],\n  fields: ['user'],\n};\n\nconst commonAggregations: AggregationKey[] = [\n  'avg',\n  'percentile',\n  'p50',\n  'p75',\n  'p95',\n  'p99',\n  'p100',\n];\n\nconst allAggregations: AggregationKey[] = [\n  ...commonAggregations,\n  'failure_rate',\n  'apdex',\n  'count',\n];\n\nexport function getWizardAlertFieldConfig(\n  alertType: AlertType,\n  dataset: Dataset\n): OptionConfig {\n  if (alertType === 'custom' && dataset === Dataset.ERRORS) {\n    return errorFieldConfig;\n  }\n  // If user selected apdex we must include that in the OptionConfig as it has a user specified column\n  const aggregations =\n    alertType === 'apdex' || alertType === 'custom'\n      ? allAggregations\n      : commonAggregations;\n  return {\n    aggregations,\n    fields: ['transaction.duration'],\n    measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n  };\n}\n\n/**\n * Allowed aggregations for alerts created from wizard\n */\nexport const wizardAlertFieldConfig: OptionConfig = {\n  aggregations: commonAggregations,\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\n/**\n * Allowed transaction aggregations for alerts\n */\nexport const transactionFieldConfig: OptionConfig = {\n  aggregations: allAggregations,\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\nexport function createDefaultTrigger(label: 'critical' | 'warning'): Trigger {\n  return {\n    label,\n    alertThreshold: '',\n    actions: [],\n  };\n}\n\nexport function createDefaultRule(): UnsavedIncidentRule {\n  return {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n    aggregate: DEFAULT_AGGREGATE,\n    query: '',\n    timeWindow: 1,\n    triggers: [createDefaultTrigger('critical'), createDefaultTrigger('warning')],\n    projects: [],\n    environment: null,\n    resolveThreshold: '',\n    thresholdType: AlertRuleThresholdType.ABOVE,\n  };\n}\n\n/**\n * Create an unsaved alert from a discover EventView object\n */\nexport function createRuleFromEventView(eventView: EventView): UnsavedIncidentRule {\n  const parsedQuery = getQueryDatasource(eventView.query);\n  const datasetAndEventtypes = parsedQuery\n    ? DATA_SOURCE_TO_SET_AND_EVENT_TYPES[parsedQuery.source]\n    : DATA_SOURCE_TO_SET_AND_EVENT_TYPES.error;\n  return {\n    ...createDefaultRule(),\n    ...datasetAndEventtypes,\n    query: parsedQuery?.query ?? eventView.query,\n    // If creating a metric alert for transactions, default to the p95 metric\n    aggregate:\n      datasetAndEventtypes.dataset === 'transactions'\n        ? 'p95(transaction.duration)'\n        : eventView.getYAxis(),\n    environment: eventView.environment.length ? eventView.environment[0] : null,\n  };\n}\n\nexport function createRuleFromWizardTemplate(\n  wizardTemplate: WizardRuleTemplate\n): UnsavedIncidentRule {\n  const {eventTypes, ...aggregateDataset} = wizardTemplate;\n  return {\n    ...createDefaultRule(),\n    eventTypes: [eventTypes],\n    ...aggregateDataset,\n  };\n}\n","import {NewQuery, Project} from 'app/types';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {Dataset} from 'app/views/alerts/incidentRules/types';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n","import Link from 'app/components/links/link';\nimport {t} from 'app/locale';\nimport {Project} from 'app/types';\nimport {DisplayModes} from 'app/utils/discover/types';\nimport {MutableSearch} from 'app/utils/tokenizeSearch';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\nimport {getIncidentDiscoverUrl} from 'app/views/alerts/utils/getIncidentDiscoverUrl';\nimport {transactionSummaryRouteWithQuery} from 'app/views/performance/transactionSummary/utils';\n\nimport {Dataset} from './types';\n\ntype PresetCta = {\n  /**\n   * The location to direct to upon clicking the CTA.\n   */\n  to: React.ComponentProps<typeof Link>['to'];\n  /**\n   * The CTA text\n   */\n  buttonText: string;\n  /**\n   * The tooltip title for the CTA button, may be empty.\n   */\n  title?: string;\n};\n\ntype PresetCtaOpts = {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n};\n\ntype Preset = {\n  /**\n   * The regex used to match aggregates to this preset.\n   */\n  match: RegExp;\n  /**\n   * The name of the preset\n   */\n  name: string;\n  /**\n   * The dataset that this preset applys to.\n   */\n  validDataset: Dataset[];\n  /**\n   * The default aggregate to use when selecting this preset\n   */\n  default: string;\n  /**\n   * Generates the CTA component\n   */\n  makeCtaParams: (opts: PresetCtaOpts) => PresetCta;\n};\n\nexport const PRESET_AGGREGATES: Preset[] = [\n  {\n    name: t('Error count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count()',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Users affected'),\n    match: /^count_unique\\(tags\\[sentry:user\\]\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count_unique(tags[sentry:user])',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Latency'),\n    match: /^(p[0-9]{2,3}|percentile\\(transaction\\.duration,[^)]+\\)|avg\\([^)]+\\))/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'percentile(transaction.duration, 0.95)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Latency by Transaction'),\n      }),\n  },\n  {\n    name: t('Apdex'),\n    match: /^apdex\\([0-9.]+\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'apdex(300)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Apdex by Transaction'),\n      }),\n  },\n  {\n    name: t('Transaction Count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'count()',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts => makeGenericTransactionCta({opts}),\n  },\n  {\n    name: t('Failure rate'),\n    match: /^failure_rate\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'failure_rate()',\n    /**\n     * See makeFailureRateCta\n     */\n    makeCtaParams: makeFailureRateCta,\n  },\n];\n\n/**\n * - CASE 1: If has a specific transaction filter\n *   - CTA is: \"View Transaction Summary\"\n *   - Tooltip is the transaction name\n *   - the same period as the alert graph (i.e. with alert start time in the middle)\n *\n * - CASE 2: If transaction is NOT filtered, or has a * filter:\n *   - \"Open in Discover\" button with optional tooltip which opens a discover view with...\n *      - fields {transaction, count(), <metric>} sorted by count()\n *      - top-5 activated\n */\nfunction makeGenericTransactionCta(opts: {\n  opts: PresetCtaOpts;\n  tooltip?: string;\n}): PresetCta {\n  const {\n    opts: {orgSlug, projects, incident, stats},\n    tooltip,\n  } = opts;\n\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = new MutableSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getFilterValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  // CASE 1\n  if (transaction !== undefined) {\n    const period = getStartEndFromStats(stats);\n\n    const summaryUrl = transactionSummaryRouteWithQuery({\n      orgSlug,\n      transaction,\n      projectID: projects\n        .filter(({slug}) => incident.projects.includes(slug))\n        .map(({id}) => id),\n      query: {...period},\n    });\n\n    return {\n      to: summaryUrl,\n      buttonText: t('View Transaction Summary'),\n      title: transaction,\n    };\n  }\n\n  // CASE 2\n  const extraQueryParams = {\n    fields: [...new Set(['transaction', 'count()', incident.alertRule.aggregate])],\n    orderby: '-count',\n    display: DisplayModes.TOP5,\n  };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: tooltip,\n  };\n}\n\n/**\n * - CASE 1: Filtered to a specific transaction, \"Open in Discover\" with...\n *   - fields [transaction.status, count()] sorted by count(),\n *   - \"Top 5 period\" activated.\n *\n * - CASE 2: If filtered on multiple transactions, \"Open in Discover\" button\n *   with tooltip \"Failure rate by transaction\" which opens a discover view\n *   - fields [transaction, failure_rate()] sorted by failure_rate\n *   - top 5 activated\n */\nfunction makeFailureRateCta({orgSlug, incident, projects, stats}: PresetCtaOpts) {\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = new MutableSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getFilterValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  const extraQueryParams =\n    transaction !== undefined\n      ? // CASE 1\n        {\n          fields: ['transaction.status', 'count()'],\n          orderby: '-count',\n          display: DisplayModes.TOP5,\n        }\n      : // Case 2\n        {\n          fields: ['transaction', 'failure_rate()'],\n          orderby: '-failure_rate',\n          display: DisplayModes.TOP5,\n        };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: transaction === undefined ? t('Failure rate by transaction') : undefined,\n  };\n}\n\n/**\n * Get the CTA used for alerts that do not have a preset\n */\nexport function makeDefaultCta({\n  orgSlug,\n  projects,\n  incident,\n  stats,\n}: PresetCtaOpts): PresetCta {\n  if (!incident) {\n    return {\n      buttonText: t('Open in Discover'),\n      to: '',\n    };\n  }\n\n  const extraQueryParams = {\n    display: DisplayModes.TOP5,\n  };\n\n  return {\n    buttonText: t('Open in Discover'),\n    to: getIncidentDiscoverUrl({orgSlug, projects, incident, stats, extraQueryParams}),\n  };\n}\n","import {t} from 'app/locale';\n\nexport enum AlertRuleThresholdType {\n  ABOVE,\n  BELOW,\n}\n\nexport enum Dataset {\n  ERRORS = 'events',\n  TRANSACTIONS = 'transactions',\n}\n\nexport enum EventTypes {\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport enum Datasource {\n  ERROR_DEFAULT = 'error_default',\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport type UnsavedTrigger = {\n  // UnsavedTrigger can be apart of an Unsaved Alert Rule that does not have an\n  // id yet\n  alertRuleId?: string;\n  label: string;\n  alertThreshold: number | '' | null;\n  actions: Action[];\n};\n\nexport type ThresholdControlValue = {\n  thresholdType: AlertRuleThresholdType;\n  /**\n   * Resolve threshold is optional, so it can be null\n   */\n  threshold: number | '' | null;\n};\n\ntype SavedTrigger = Omit<UnsavedTrigger, 'actions'> & {\n  id: string;\n  dateCreated: string;\n  actions: Action[];\n};\n\nexport type Trigger = Partial<SavedTrigger> & UnsavedTrigger;\n\nexport type UnsavedIncidentRule = {\n  dataset: Dataset;\n  projects: string[];\n  environment: string | null;\n  query: string;\n  timeWindow: TimeWindow;\n  triggers: Trigger[];\n  aggregate: string;\n  thresholdType: AlertRuleThresholdType;\n  resolveThreshold: number | '' | null;\n  eventTypes?: EventTypes[];\n  owner?: string | null;\n};\n\nexport type SavedIncidentRule = UnsavedIncidentRule & {\n  dateCreated: string;\n  dateModified: string;\n  id: string;\n  status: number;\n  name: string;\n  createdBy?: {id: number; email: string; name: string} | null;\n  originalAlertRuleId?: number | null;\n};\n\nexport type IncidentRule = Partial<SavedIncidentRule> & UnsavedIncidentRule;\n\nexport enum TimePeriod {\n  SIX_HOURS = '6h',\n  ONE_DAY = '1d',\n  THREE_DAYS = '3d',\n  // Seven days is actually 10080m but we have a max of 10000 events\n  SEVEN_DAYS = '10000m',\n  FOURTEEN_DAYS = '14d',\n  THIRTY_DAYS = '30d',\n}\n\nexport enum TimeWindow {\n  ONE_MINUTE = 1,\n  FIVE_MINUTES = 5,\n  TEN_MINUTES = 10,\n  FIFTEEN_MINUTES = 15,\n  THIRTY_MINUTES = 30,\n  ONE_HOUR = 60,\n  TWO_HOURS = 120,\n  FOUR_HOURS = 240,\n  ONE_DAY = 1440,\n}\n\nexport enum ActionType {\n  EMAIL = 'email',\n  SLACK = 'slack',\n  PAGERDUTY = 'pagerduty',\n  MSTEAMS = 'msteams',\n  SENTRY_APP = 'sentry_app',\n}\n\nexport const ActionLabel = {\n  [ActionType.EMAIL]: t('Email'),\n  [ActionType.SLACK]: t('Slack'),\n  [ActionType.PAGERDUTY]: t('Pagerduty'),\n  [ActionType.MSTEAMS]: t('MS Teams'),\n  [ActionType.SENTRY_APP]: t('Notification'),\n};\n\nexport enum TargetType {\n  // A direct reference, like an email address, Slack channel, or PagerDuty service\n  SPECIFIC = 'specific',\n\n  // A specific user. This could be used to grab the user's email address.\n  USER = 'user',\n\n  // A specific team. This could be used to send an email to everyone associated with a team.\n  TEAM = 'team',\n\n  // A Sentry App instead of any of the above.\n  SENTRY_APP = 'sentry_app',\n}\n\nexport const TargetLabel = {\n  [TargetType.USER]: t('Member'),\n  [TargetType.TEAM]: t('Team'),\n};\n\n/**\n * This is an available action template that is associated to a Trigger in a\n * Metric Alert Rule. They are defined by the available-actions API.\n */\nexport type MetricActionTemplate = {\n  /**\n   * The integration type e.g. 'email'\n   */\n  type: ActionType;\n\n  /**\n   * See `TargetType`\n   */\n  allowedTargetTypes: TargetType[];\n\n  /**\n   * Name of the integration. This is a text field that differentiates integrations from the same provider from each other\n   */\n  integrationName?: string;\n\n  /**\n   * Integration id for this `type`, should be passed to backend as `integrationId` when creating an action\n   */\n  integrationId?: number;\n\n  /**\n   * Name of the SentryApp. Like `integrationName`, this differentiates SentryApps from each other.\n   */\n  sentryAppName?: string;\n\n  /**\n   * SentryApp id for this `type`, should be passed to backend as `sentryAppId` when creating an action.\n   */\n  sentryAppId?: number;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options?: Array<{label: string; value: any}>;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n\n/**\n * This is the user's configured action\n */\nexport type Action = UnsavedAction & Partial<SavedActionFields>;\nexport type SavedAction = Omit<UnsavedAction, 'unsavedDateCreated' | 'unsavedId'> &\n  SavedActionFields;\n\ntype SavedActionFields = {\n  /**\n   * The id of the alert rule this action belongs to\n   */\n  alertRuleTriggerId: string;\n\n  /**\n   * A human readable description of the action generated by server\n   */\n  desc: string;\n\n  /**\n   * model id of the action\n   */\n  id: string;\n\n  /**\n   * date created\n   */\n  dateCreated: string;\n};\n\ntype UnsavedAction = {\n  unsavedId: string;\n  /** Used to maintain order of unsaved actions */\n  unsavedDateCreated: string;\n  type: ActionType;\n\n  targetType: TargetType | null;\n\n  /**\n   * How to identify the target. Can be email, slack channel, pagerduty service,\n   * user_id, team_id, SentryApp id, etc\n   */\n  targetIdentifier: string | null;\n\n  /**\n   * The id of the integration, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  integrationId?: number | null;\n\n  /**\n   * The id of the SentryApp, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  sentryAppId?: number | null;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options: Array<{label: string; value: any}> | null;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n","import {User} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {IncidentRule} from 'app/views/alerts/incidentRules/types';\n\ntype Data = [number, {count: number}[]][];\n\nexport type Incident = {\n  dateClosed: string | null;\n  dateStarted: string;\n  dateDetected: string;\n  dateCreated: string;\n  id: string;\n  identifier: string;\n  isSubscribed: boolean;\n  groups: string[]; // Array of group ids\n  discoverQuery: string;\n  organizationId: string;\n  projects: string[]; // Array of slugs\n  seenBy: User[];\n  status: IncidentStatus;\n  statusMethod: IncidentStatusMethod;\n  title: string;\n  hasSeen: boolean;\n  alertRule: IncidentRule;\n  activities?: ActivityType[];\n};\n\nexport type IncidentStats = {\n  eventStats: {\n    data: Data;\n  };\n  totalEvents: number;\n  uniqueUsers: number;\n};\n\nexport type ActivityTypeDraft = {\n  comment: null | string;\n  dateCreated: string;\n  id: string;\n  incidentIdentifier: string;\n  type: IncidentActivityType;\n  user: User | null;\n};\n\nexport type ActivityType = ActivityTypeDraft & {\n  eventStats?: {data: Data};\n  previousValue: string | null;\n  value: string | null;\n};\n\nexport enum IncidentActivityType {\n  CREATED = 0,\n  DETECTED = 1,\n  STATUS_CHANGE = 2,\n  COMMENT = 3,\n  STARTED = 4,\n}\n\nexport enum IncidentStatus {\n  OPENED = 1,\n  CLOSED = 2,\n  WARNING = 10,\n  CRITICAL = 20,\n}\n\nexport enum IncidentStatusMethod {\n  MANUAL = 1,\n  RULE_UPDATED = 2,\n  RULE_TRIGGERED = 3,\n}\n\nexport enum AlertRuleStatus {\n  PENDING = 0,\n  SNAPSHOT = 4,\n  DISABLED = 5,\n}\n\nexport type CombinedMetricIssueAlerts = (IssueAlertRule | IncidentRule) & {\n  type: string;\n  latestIncident?: Incident | null;\n};\n","import {Client} from 'app/api';\nimport {t} from 'app/locale';\nimport {NewQuery, Project} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {getUtcDateString} from 'app/utils/dates';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {PRESET_AGGREGATES} from 'app/views/alerts/incidentRules/presets';\nimport {\n  Dataset,\n  Datasource,\n  EventTypes,\n  IncidentRule,\n  SavedIncidentRule,\n} from 'app/views/alerts/incidentRules/types';\n\nimport {Incident, IncidentStats, IncidentStatus} from '../types';\n\n// Use this api for requests that are getting cancelled\nconst uncancellableApi = new Client();\n\nexport function fetchAlertRule(orgId: string, ruleId: string): Promise<IncidentRule> {\n  return uncancellableApi.requestPromise(\n    `/organizations/${orgId}/alert-rules/${ruleId}/`\n  );\n}\n\nexport function fetchIncidentsForRule(\n  orgId: string,\n  alertRule: string,\n  start: string,\n  end: string\n): Promise<Incident[]> {\n  return uncancellableApi.requestPromise(`/organizations/${orgId}/incidents/`, {\n    query: {\n      alertRule,\n      includeSnapshots: true,\n      start,\n      end,\n      expand: ['activities', 'seen_by', 'original_alert_rule'],\n    },\n  });\n}\n\nexport function fetchIncident(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`);\n}\n\nexport function fetchIncidentStats(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<IncidentStats> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/stats/`);\n}\n\nexport function updateSubscription(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  isSubscribed?: boolean\n): Promise<Incident> {\n  const method = isSubscribed ? 'POST' : 'DELETE';\n  return api.requestPromise(\n    `/organizations/${orgId}/incidents/${alertId}/subscriptions/`,\n    {\n      method,\n    }\n  );\n}\n\nexport function updateStatus(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  status: IncidentStatus\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`, {\n    method: 'PUT',\n    data: {\n      status,\n    },\n  });\n}\n\n/**\n * Is incident open?\n *\n * @param {Object} incident Incident object\n * @returns {Boolean}\n */\nexport function isOpen(incident: Incident): boolean {\n  switch (incident.status) {\n    case IncidentStatus.CLOSED:\n      return false;\n    default:\n      return true;\n  }\n}\n\nexport function getIncidentMetricPreset(incident: Incident) {\n  const alertRule = incident?.alertRule;\n  const aggregate = alertRule?.aggregate ?? '';\n  const dataset = alertRule?.dataset ?? Dataset.ERRORS;\n\n  return PRESET_AGGREGATES.find(\n    p => p.validDataset.includes(dataset) && p.match.test(aggregate)\n  );\n}\n\n/**\n * Gets start and end date query parameters from stats\n */\nexport function getStartEndFromStats(stats: IncidentStats) {\n  const start = getUtcDateString(stats.eventStats.data[0][0] * 1000);\n  const end = getUtcDateString(\n    stats.eventStats.data[stats.eventStats.data.length - 1][0] * 1000\n  );\n\n  return {start, end};\n}\n\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n\nexport function isIssueAlert(\n  data: IssueAlertRule | SavedIncidentRule | IncidentRule\n): data is IssueAlertRule {\n  return !data.hasOwnProperty('triggers');\n}\n\nexport const DATA_SOURCE_LABELS = {\n  [Dataset.ERRORS]: t('Errors'),\n  [Dataset.TRANSACTIONS]: t('Transactions'),\n  [Datasource.ERROR_DEFAULT]: t('event.type:error OR event.type:default'),\n  [Datasource.ERROR]: t('event.type:error'),\n  [Datasource.DEFAULT]: t('event.type:default'),\n  [Datasource.TRANSACTION]: t('event.type:transaction'),\n};\n\n// Maps a datasource to the relevant dataset and event_types for the backend to use\nexport const DATA_SOURCE_TO_SET_AND_EVENT_TYPES = {\n  [Datasource.ERROR_DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR, EventTypes.DEFAULT],\n  },\n  [Datasource.ERROR]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n  },\n  [Datasource.DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.DEFAULT],\n  },\n  [Datasource.TRANSACTION]: {\n    dataset: Dataset.TRANSACTIONS,\n    eventTypes: [EventTypes.TRANSACTION],\n  },\n};\n\n// Converts the given dataset and event types array to a datasource for the datasource dropdown\nexport function convertDatasetEventTypesToSource(\n  dataset: Dataset,\n  eventTypes: EventTypes[]\n) {\n  // transactions only has one datasource option regardless of event type\n  if (dataset === Dataset.TRANSACTIONS) {\n    return Datasource.TRANSACTION;\n  }\n  // if no event type was provided use the default datasource\n  if (!eventTypes) {\n    return Datasource.ERROR;\n  }\n\n  if (eventTypes.includes(EventTypes.DEFAULT) && eventTypes.includes(EventTypes.ERROR)) {\n    return Datasource.ERROR_DEFAULT;\n  } else if (eventTypes.includes(EventTypes.DEFAULT)) {\n    return Datasource.DEFAULT;\n  } else {\n    return Datasource.ERROR;\n  }\n}\n\n/**\n * Attempt to guess the data source of a discover query\n *\n * @returns An object containing the datasource and new query without the datasource.\n * Returns null on no datasource.\n */\nexport function getQueryDatasource(\n  query: string\n): {source: Datasource; query: string} | null {\n  let match = query.match(\n    /\\(?\\bevent\\.type:(error|default|transaction)\\)?\\WOR\\W\\(?event\\.type:(error|default|transaction)\\)?/i\n  );\n  if (match) {\n    // should be [error, default] or [default, error]\n    const eventTypes = match.slice(1, 3).sort().join(',');\n    if (eventTypes !== 'default,error') {\n      return null;\n    }\n\n    return {source: Datasource.ERROR_DEFAULT, query: query.replace(match[0], '').trim()};\n  }\n\n  match = query.match(/(^|\\s)event\\.type:(error|default|transaction)/i);\n  if (match && Datasource[match[2].toUpperCase()]) {\n    return {\n      source: Datasource[match[2].toUpperCase()],\n      query: query.replace(match[0], '').trim(),\n    };\n  }\n\n  return null;\n}\n"],"names":["DEFAULT_AGGREGATE","DEFAULT_TRANSACTION_AGGREGATE","DATASET_EVENT_TYPE_FILTERS","Dataset","DATASOURCE_EVENT_TYPE_FILTERS","Datasource","errorFieldConfig","aggregations","fields","commonAggregations","allAggregations","getWizardAlertFieldConfig","alertType","dataset","measurementKeys","Object","keys","WEB_VITAL_DETAILS","transactionFieldConfig","createDefaultTrigger","label","alertThreshold","actions","createDefaultRule","eventTypes","EventTypes","aggregate","query","timeWindow","triggers","projects","environment","resolveThreshold","thresholdType","AlertRuleThresholdType","createRuleFromEventView","eventView","parsedQuery","getQueryDatasource","datasetAndEventtypes","DATA_SOURCE_TO_SET_AND_EVENT_TYPES","source","getYAxis","length","createRuleFromWizardTemplate","wizardTemplate","aggregateDataset","getIncidentDiscoverUrl","opts","orgSlug","incident","stats","extraQueryParams","timeWindowString","alertRule","start","end","getStartEndFromStats","discoverQuery","id","undefined","name","title","orderby","getAggregateAlias","yAxis","filter","slug","includes","map","Number","version","discoverView","EventView","toObject","getResultsViewUrlTarget","interval","PRESET_AGGREGATES","t","match","validDataset","default","makeCtaParams","makeDefaultCta","makeGenericTransactionCta","tooltip","to","buttonText","transaction","MutableSearch","getFilterValues","find","display","DisplayModes","period","transactionSummaryRouteWithQuery","projectID","Set","TimePeriod","TimeWindow","ActionType","ActionLabel","EMAIL","SLACK","PAGERDUTY","MSTEAMS","SENTRY_APP","TargetType","TargetLabel","USER","TEAM","IncidentActivityType","IncidentStatus","IncidentStatusMethod","AlertRuleStatus","uncancellableApi","Client","fetchAlertRule","orgId","ruleId","requestPromise","fetchIncidentsForRule","includeSnapshots","expand","fetchIncident","api","alertId","fetchIncidentStats","updateSubscription","isSubscribed","method","updateStatus","status","data","isOpen","getIncidentMetricPreset","p","test","getUtcDateString","eventStats","isIssueAlert","hasOwnProperty","DATA_SOURCE_LABELS","convertDatasetEventTypesToSource","slice","sort","join","replace","trim","toUpperCase"],"sourceRoot":""}