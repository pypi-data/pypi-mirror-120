{"version":3,"file":"chunks/app_components_modals_dashboardWidgetQuerySelectorModal_tsx-app_stores_teamStore_tsx-app_util-498cf4.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actions/projectActions.tsx","webpack:///./app/actions/teamActions.tsx","webpack:///./app/components/modals/dashboardWidgetQuerySelectorModal.tsx","webpack:///./app/stores/projectsStore.tsx","webpack:///./app/stores/teamStore.tsx","webpack:///./app/utils/useApi.tsx","webpack:///./app/utils/withApi.tsx","webpack:///./app/utils/withProjects.tsx","webpack:///./app/views/dashboardsV2/types.tsx","webpack:///./app/views/dashboardsV2/utils.tsx"],"sourcesContent":["import Reflux from 'reflux';\n\nexport default Reflux.createActions([\n  'addTeam',\n  'addTeamError',\n  'addTeamSuccess',\n  'changeSlug',\n  'createSuccess',\n  'loadProjects',\n  'loadStats',\n  'loadStatsError',\n  'loadStatsForProjectSuccess',\n  'loadStatsSuccess',\n  'removeProject',\n  'removeProjectError',\n  'removeProjectSuccess',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'reset',\n  'setActive',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n","import Reflux from 'reflux';\n\nconst TeamActions = Reflux.createActions([\n  'createTeam',\n  'createTeamError',\n  'createTeamSuccess',\n  'fetchAll',\n  'fetchAllError',\n  'fetchAllSuccess',\n  'fetchDetails',\n  'fetchDetailsError',\n  'fetchDetailsSuccess',\n  'loadTeams',\n  'removeTeam',\n  'removeTeamError',\n  'removeTeamSuccess',\n  'update',\n  'updateError',\n  'updateSuccess',\n]);\n\nexport default TeamActions;\n","import * as React from 'react';\nimport {browserHistory} from 'react-router';\nimport {css} from '@emotion/react';\nimport styled from '@emotion/styled';\n\nimport {ModalRenderProps} from 'app/actionCreators/modal';\nimport {Client} from 'app/api';\nimport Button from 'app/components/button';\nimport {IconChevron, IconSearch} from 'app/icons';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {GlobalSelection, Organization} from 'app/types';\nimport withApi from 'app/utils/withApi';\nimport withGlobalSelection from 'app/utils/withGlobalSelection';\nimport {Widget} from 'app/views/dashboardsV2/types';\nimport {eventViewFromWidget} from 'app/views/dashboardsV2/utils';\nimport Input from 'app/views/settings/components/forms/controls/input';\n\nexport type DashboardWidgetQuerySelectorModalOptions = {\n  organization: Organization;\n  widget: Widget;\n};\n\ntype Props = ModalRenderProps &\n  DashboardWidgetQuerySelectorModalOptions & {\n    api: Client;\n    organization: Organization;\n    selection: GlobalSelection;\n  };\n\nclass DashboardWidgetQuerySelectorModal extends React.Component<Props> {\n  renderQueries() {\n    const {organization, widget, selection} = this.props;\n    const querySearchBars = widget.queries.map((query, index) => {\n      const eventView = eventViewFromWidget(\n        widget.title,\n        query,\n        selection,\n        widget.displayType\n      );\n      return (\n        <React.Fragment key={index}>\n          <QueryContainer>\n            <Container>\n              <SearchLabel htmlFor=\"smart-search-input\" aria-label={t('Search events')}>\n                <IconSearch />\n              </SearchLabel>\n              <StyledInput value={query.conditions} disabled />\n            </Container>\n            <OpenInDiscoverButton\n              priority=\"primary\"\n              icon={<IconChevron size=\"xs\" direction=\"right\" />}\n              onClick={() => {\n                browserHistory.push(eventView.getResultsViewUrlTarget(organization.slug));\n              }}\n            />\n          </QueryContainer>\n        </React.Fragment>\n      );\n    });\n    return querySearchBars;\n  }\n\n  render() {\n    const {Body, Header, widget} = this.props;\n    return (\n      <React.Fragment>\n        <Header closeButton>\n          <h4>{widget.title}</h4>\n        </Header>\n        <Body>\n          <p>\n            {t(\n              'Multiple queries were used to create this widget visualization. Which query would you like to view in Discover?'\n            )}\n          </p>\n          {this.renderQueries()}\n        </Body>\n      </React.Fragment>\n    );\n  }\n}\n\nconst StyledInput = styled(Input)`\n  text-overflow: ellipsis;\n  padding: 0px;\n  box-shadow: none;\n  height: auto;\n  &:disabled {\n    border: none;\n    cursor: default;\n  }\n`;\nconst QueryContainer = styled('div')`\n  display: flex;\n  margin-bottom: ${space(1)};\n`;\nconst OpenInDiscoverButton = styled(Button)`\n  margin-left: ${space(1)};\n`;\n\nconst Container = styled('div')`\n  border: 1px solid ${p => p.theme.border};\n  box-shadow: inset ${p => p.theme.dropShadowLight};\n  background: ${p => p.theme.backgroundSecondary};\n  padding: 7px ${space(1)};\n  position: relative;\n  display: grid;\n  grid-template-columns: max-content 1fr max-content;\n  grid-gap: ${space(1)};\n  align-items: start;\n  flex-grow: 1;\n  border-radius: ${p => p.theme.borderRadius};\n`;\n\nconst SearchLabel = styled('label')`\n  display: flex;\n  padding: ${space(0.5)} 0;\n  margin: 0;\n  color: ${p => p.theme.gray300};\n`;\n\nexport const modalCss = css`\n  width: 100%;\n  max-width: 700px;\n  margin: 70px auto;\n`;\n\nexport default withApi(withGlobalSelection(DashboardWidgetQuerySelectorModal));\n","import Reflux from 'reflux';\n\nimport ProjectActions from 'app/actions/projectActions';\nimport TeamActions from 'app/actions/teamActions';\nimport {Project, Team} from 'app/types';\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\ntype StatsData = Record<string, Project['stats']>;\n\n/**\n * Attributes that need typing but aren't part of the external interface,\n */\ntype Internals = {\n  itemsById: Record<string, Project>;\n  loading: boolean;\n};\n\ntype ProjectsStoreInterface = {\n  init: () => void;\n  reset: () => void;\n  loadInitialData: (projects: Project[]) => void;\n  onStatsLoadSuccess: (data: StatsData) => void;\n  onChangeSlug: (prevSlug: string, newSlug: string) => void;\n  onCreateSuccess: (project: Project) => void;\n  onUpdateSuccess: (data: Partial<Project>) => void;\n  onDeleteTeam: (slug: string) => void;\n  onRemoveTeam: (teamSlug: string, projectSlug: string) => void;\n  onAddTeam: (team: Team, projectSlug: string) => void;\n  removeTeamFromProject: (teamSlug: string, project: Project) => void;\n  getWithTeam: (teamSlug: string) => Project[];\n  getAll: () => Project[];\n  getBySlugs: (slug: string[]) => Project[];\n  getState: (slugs?: string[]) => State;\n  getById: (id?: string) => Project | undefined;\n  getBySlug: (slug?: string) => Project | undefined;\n};\n\nconst storeConfig: Reflux.StoreDefinition & Internals & ProjectsStoreInterface = {\n  itemsById: {},\n  loading: true,\n\n  init() {\n    this.reset();\n\n    this.listenTo(ProjectActions.addTeamSuccess, this.onAddTeam);\n    this.listenTo(ProjectActions.changeSlug, this.onChangeSlug);\n    this.listenTo(ProjectActions.createSuccess, this.onCreateSuccess);\n    this.listenTo(ProjectActions.loadProjects, this.loadInitialData);\n    this.listenTo(ProjectActions.loadStatsSuccess, this.onStatsLoadSuccess);\n    this.listenTo(ProjectActions.removeTeamSuccess, this.onRemoveTeam);\n    this.listenTo(ProjectActions.reset, this.reset);\n    this.listenTo(ProjectActions.updateSuccess, this.onUpdateSuccess);\n\n    this.listenTo(TeamActions.removeTeamSuccess, this.onDeleteTeam);\n  },\n\n  reset() {\n    this.itemsById = {};\n    this.loading = true;\n  },\n\n  loadInitialData(items: Project[]) {\n    this.itemsById = items.reduce((map, project) => {\n      map[project.id] = project;\n      return map;\n    }, {});\n    this.loading = false;\n    this.trigger(new Set(Object.keys(this.itemsById)));\n  },\n\n  onChangeSlug(prevSlug: string, newSlug: string) {\n    const prevProject = this.getBySlug(prevSlug);\n\n    // This shouldn't happen\n    if (!prevProject) {\n      return;\n    }\n\n    const newProject = {\n      ...prevProject,\n      slug: newSlug,\n    };\n\n    this.itemsById = {\n      ...this.itemsById,\n      [newProject.id]: newProject,\n    };\n\n    // Ideally we'd always trigger this.itemsById, but following existing patterns\n    // so we don't break things\n    this.trigger(new Set([prevProject.id]));\n  },\n\n  onCreateSuccess(project: Project) {\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: project,\n    };\n    this.trigger(new Set([project.id]));\n  },\n\n  onUpdateSuccess(data: Partial<Project>) {\n    const project = this.getById(data.id);\n    if (!project) {\n      return;\n    }\n    const newProject = Object.assign({}, project, data);\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: newProject,\n    };\n    this.trigger(new Set([data.id]));\n  },\n\n  onStatsLoadSuccess(data) {\n    const touchedIds: string[] = [];\n    Object.entries(data || {}).forEach(([projectId, stats]) => {\n      if (projectId in this.itemsById) {\n        this.itemsById[projectId].stats = stats;\n        touchedIds.push(projectId);\n      }\n    });\n    this.trigger(new Set(touchedIds));\n  },\n\n  /**\n   * Listener for when a team is completely removed\n   *\n   * @param teamSlug Team Slug\n   */\n  onDeleteTeam(teamSlug: string) {\n    // Look for team in all projects\n    const projectIds = this.getWithTeam(teamSlug).map(projectWithTeam => {\n      this.removeTeamFromProject(teamSlug, projectWithTeam);\n      return projectWithTeam.id;\n    });\n\n    this.trigger(new Set([projectIds]));\n  },\n\n  onRemoveTeam(teamSlug: string, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n    if (!project) {\n      return;\n    }\n\n    this.removeTeamFromProject(teamSlug, project);\n    this.trigger(new Set([project.id]));\n  },\n\n  onAddTeam(team: Team, projectSlug: string) {\n    const project = this.getBySlug(projectSlug);\n\n    // Don't do anything if we can't find a project\n    if (!project) {\n      return;\n    }\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: [...project.teams, team],\n      },\n    };\n\n    this.trigger(new Set([project.id]));\n  },\n\n  // Internal method, does not trigger\n  removeTeamFromProject(teamSlug: string, project: Project) {\n    const newTeams = project.teams.filter(({slug}) => slug !== teamSlug);\n\n    this.itemsById = {\n      ...this.itemsById,\n      [project.id]: {\n        ...project,\n        teams: newTeams,\n      },\n    };\n  },\n\n  /**\n   * Returns a list of projects that has the specified team\n   *\n   * @param {String} teamSlug Slug of team to find in projects\n   */\n  getWithTeam(teamSlug: string) {\n    return this.getAll().filter(({teams}) => teams.find(({slug}) => slug === teamSlug));\n  },\n\n  getAll() {\n    return Object.values(this.itemsById).sort((a: Project, b: Project) => {\n      if (a.slug > b.slug) {\n        return 1;\n      }\n      if (a.slug < b.slug) {\n        return -1;\n      }\n      return 0;\n    });\n  },\n\n  getById(id) {\n    return this.getAll().find(project => project.id === id);\n  },\n\n  getBySlug(slug) {\n    return this.getAll().find(project => project.slug === slug);\n  },\n\n  getBySlugs(slugs: string[]) {\n    return this.getAll().filter(project => slugs.includes(project.slug));\n  },\n\n  getState(slugs?: string[]): State {\n    return {\n      projects: slugs ? this.getBySlugs(slugs) : this.getAll(),\n      loading: this.loading,\n    };\n  },\n};\n\nconst ProjectsStore = Reflux.createStore(storeConfig) as Reflux.Store &\n  ProjectsStoreInterface;\n\nexport default ProjectsStore;\n","import Reflux from 'reflux';\n\nimport TeamActions from 'app/actions/teamActions';\nimport {Team} from 'app/types';\n\ntype State = {\n  teams: Team[];\n  loading: boolean;\n  hasMore: boolean | null;\n};\n\ntype TeamStoreInterface = {\n  initialized: boolean;\n  state: State;\n  reset: () => void;\n  loadInitialData: (items: Team[], hasMore?: boolean | null) => void;\n  onUpdateSuccess: (itemId: string, response: Team) => void;\n  onRemoveSuccess: (slug: string) => void;\n  onCreateSuccess: (team: Team) => void;\n  get: () => State;\n  getAll: () => Team[];\n  getById: (id: string) => Team | null;\n  getBySlug: (slug: string) => Team | null;\n};\n\nconst teamStoreConfig: Reflux.StoreDefinition & TeamStoreInterface = {\n  initialized: false,\n  state: {\n    teams: [],\n    loading: true,\n    hasMore: null,\n  },\n\n  init() {\n    this.reset();\n\n    this.listenTo(TeamActions.createTeamSuccess, this.onCreateSuccess);\n    this.listenTo(TeamActions.fetchDetailsSuccess, this.onUpdateSuccess);\n    this.listenTo(TeamActions.loadTeams, this.loadInitialData);\n    this.listenTo(TeamActions.removeTeamSuccess, this.onRemoveSuccess);\n    this.listenTo(TeamActions.updateSuccess, this.onUpdateSuccess);\n  },\n\n  reset() {\n    this.state = {teams: [], loading: true, hasMore: null};\n  },\n\n  loadInitialData(items, hasMore = null) {\n    this.initialized = true;\n    this.state = {\n      teams: items.sort((a, b) => a.slug.localeCompare(b.slug)),\n      loading: false,\n      hasMore,\n    };\n    this.trigger(new Set(items.map(item => item.id)));\n  },\n\n  onUpdateSuccess(itemId, response) {\n    if (!response) {\n      return;\n    }\n\n    const item = this.getBySlug(itemId);\n\n    if (!item) {\n      this.state = {\n        ...this.state,\n        teams: [...this.state.teams, response],\n      };\n\n      this.trigger(new Set([itemId]));\n      return;\n    }\n\n    // Slug was changed\n    // Note: This is the proper way to handle slug changes but unfortunately not all of our\n    // components use stores correctly. To be safe reload browser :((\n    if (response.slug !== itemId) {\n      // Replace the team\n      const teams = [...this.state.teams.filter(({slug}) => slug !== itemId), response];\n\n      this.state = {...this.state, teams};\n      this.trigger(new Set([response.slug]));\n      return;\n    }\n\n    const newTeams = [...this.state.teams];\n    const index = newTeams.findIndex(team => team.slug === response.slug);\n    newTeams[index] = response;\n\n    this.state = {...this.state, teams: newTeams};\n    this.trigger(new Set([itemId]));\n  },\n\n  onRemoveSuccess(slug: string) {\n    const {teams} = this.state;\n    this.loadInitialData(teams.filter(team => team.slug !== slug));\n  },\n\n  onCreateSuccess(team: Team) {\n    this.loadInitialData([...this.state.teams, team]);\n  },\n\n  get() {\n    return this.state;\n  },\n\n  getById(id: string) {\n    const {teams} = this.state;\n    return teams.find(item => item.id.toString() === id.toString()) || null;\n  },\n\n  getBySlug(slug: string) {\n    const {teams} = this.state;\n    return teams.find(item => item.slug === slug) || null;\n  },\n\n  getAll() {\n    return this.state.teams;\n  },\n};\n\nconst TeamStore = Reflux.createStore(teamStoreConfig) as Reflux.Store &\n  TeamStoreInterface;\n\nexport default TeamStore;\n","import {useEffect, useRef} from 'react';\n\nimport {Client} from 'app/api';\n\ntype Options = {\n  /**\n   * Enabling this option will disable clearing in-flight requests when the\n   * component is unmounted.\n   *\n   * This may be useful in situations where your component needs to finish up\n   * somewhere the client was passed into some type of action creator and the\n   * component is unmounted.\n   */\n  persistInFlight?: boolean;\n  /**\n   * An existing API client may be provided.\n   *\n   * This is a continent way to re-use clients and still inherit the\n   * persistInFlight configuration.\n   */\n  api?: Client;\n};\n\n/**\n * Returns an API client that will have it's requests canceled when the owning\n * React component is unmounted (may be disabled via options).\n */\nfunction useApi({persistInFlight, api: providedApi}: Options = {}) {\n  const localApi = useRef<Client>();\n\n  // Lazily construct the client if we weren't provided with one\n  if (localApi.current === undefined && providedApi === undefined) {\n    localApi.current = new Client();\n  }\n\n  // Use the provided client if available\n  const api = providedApi ?? localApi.current!;\n\n  function handleCleanup() {\n    !persistInFlight && api.clear();\n  }\n\n  useEffect(() => handleCleanup, []);\n\n  return api;\n}\n\nexport default useApi;\n","import {Client} from 'app/api';\nimport getDisplayName from 'app/utils/getDisplayName';\nimport useApi from 'app/utils/useApi';\n\ntype InjectedApiProps = {\n  api: Client;\n};\n\ntype WrappedProps<P> = Omit<P, keyof InjectedApiProps> & Partial<InjectedApiProps>;\n\n/**\n * XXX: Prefer useApi if you are wrapping a Function Component!\n *\n * React Higher-Order Component (HoC) that provides \"api\" client when mounted,\n * and clears API requests when component is unmounted.\n *\n * If an `api` prop is provided when the component is invoked it will be passed\n * through.\n */\nconst withApi = <P extends InjectedApiProps>(\n  WrappedComponent: React.ComponentType<P>,\n  options: Parameters<typeof useApi>[0] = {}\n) => {\n  const WithApi: React.FC<WrappedProps<P>> = ({api: propsApi, ...props}) => {\n    const api = useApi({api: propsApi, ...options});\n\n    return <WrappedComponent {...(props as P)} api={api} />;\n  };\n\n  WithApi.displayName = `withApi(${getDisplayName(WrappedComponent)})`;\n\n  return WithApi;\n};\n\nexport default withApi;\n","import * as React from 'react';\n\nimport ProjectsStore from 'app/stores/projectsStore';\nimport {Project} from 'app/types';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedProjectsProps = {\n  projects: Project[];\n  loadingProjects?: boolean;\n};\n\ntype State = {\n  projects: Project[];\n  loading: boolean;\n};\n\n/**\n * Higher order component that uses ProjectsStore and provides a list of projects\n */\nfunction withProjects<P extends InjectedProjectsProps>(\n  WrappedComponent: React.ComponentType<P>\n) {\n  class WithProjects extends React.Component<\n    Omit<P, keyof InjectedProjectsProps> & Partial<InjectedProjectsProps>,\n    State\n  > {\n    static displayName = `withProjects(${getDisplayName(WrappedComponent)})`;\n\n    state: State = ProjectsStore.getState();\n\n    componentWillUnmount() {\n      this.unsubscribe();\n    }\n\n    unsubscribe = ProjectsStore.listen(\n      () => this.setState(ProjectsStore.getState()),\n      undefined\n    );\n\n    render() {\n      return (\n        <WrappedComponent\n          {...(this.props as P)}\n          projects={this.state.projects}\n          loadingProjects={this.state.loading}\n        />\n      );\n    }\n  }\n\n  return WithProjects;\n}\n\nexport default withProjects;\n","import {User} from 'app/types';\n\nexport enum DisplayType {\n  AREA = 'area',\n  BAR = 'bar',\n  LINE = 'line',\n  TABLE = 'table',\n  WORLD_MAP = 'world_map',\n  BIG_NUMBER = 'big_number',\n  STACKED_AREA = 'stacked_area',\n}\n\nexport type WidgetQuery = {\n  name: string;\n  fields: string[];\n  conditions: string;\n  orderby: string;\n};\n\nexport type Widget = {\n  id?: string;\n  title: string;\n  displayType: DisplayType;\n  interval: string;\n  queries: WidgetQuery[];\n};\n\n/**\n * The response shape from dashboard list endpoint\n */\nexport type DashboardListItem = {\n  id: string;\n  title: string;\n  dateCreated?: string;\n  createdBy?: User;\n  widgetDisplay: DisplayType[];\n};\n\n/**\n * Saved dashboard with widgets\n */\nexport type DashboardDetails = {\n  title: string;\n  widgets: Widget[];\n  id: string;\n  dateCreated: string;\n  createdBy?: User;\n};\n\nexport enum DashboardState {\n  VIEW = 'view',\n  EDIT = 'edit',\n  CREATE = 'create',\n  PENDING_DELETE = 'pending_delete',\n}\n","import {Query} from 'history';\nimport cloneDeep from 'lodash/cloneDeep';\nimport pick from 'lodash/pick';\n\nimport {GlobalSelection} from 'app/types';\nimport {getUtcDateString} from 'app/utils/dates';\nimport EventView from 'app/utils/discover/eventView';\n\nimport {DashboardDetails, DisplayType, Widget, WidgetQuery} from './types';\n\nexport function cloneDashboard(dashboard: DashboardDetails): DashboardDetails {\n  return cloneDeep(dashboard);\n}\n\nexport function eventViewFromWidget(\n  title: string,\n  query: WidgetQuery,\n  selection: GlobalSelection,\n  widgetType?: DisplayType\n): EventView {\n  const {start, end, period: statsPeriod} = selection.datetime;\n  const {projects, environments} = selection;\n\n  // World Map requires an additional column (geo.country_code) to display in discover when navigating from the widget\n  const fields =\n    widgetType === DisplayType.WORLD_MAP\n      ? ['geo.country_code', ...query.fields]\n      : query.fields;\n  const conditions =\n    widgetType === DisplayType.WORLD_MAP\n      ? `${query.conditions} has:geo.country_code`\n      : query.conditions;\n\n  return EventView.fromSavedQuery({\n    id: undefined,\n    name: title,\n    version: 2,\n    fields,\n    query: conditions,\n    orderby: query.orderby,\n    projects,\n    range: statsPeriod,\n    start: start ? getUtcDateString(start) : undefined,\n    end: end ? getUtcDateString(end) : undefined,\n    environment: environments,\n  });\n}\n\nfunction coerceStringToArray(value?: string | string[] | null) {\n  return typeof value === 'string' ? [value] : value;\n}\n\nexport function constructWidgetFromQuery(query?: Query): Widget | undefined {\n  if (query) {\n    const queryNames = coerceStringToArray(query.queryNames);\n    const queryConditions = coerceStringToArray(query.queryConditions);\n    const queryFields = coerceStringToArray(query.queryFields);\n    const queries: WidgetQuery[] = [];\n    if (\n      queryConditions &&\n      queryNames &&\n      queryFields &&\n      typeof query.queryOrderby === 'string'\n    )\n      queryConditions.forEach((condition, index) => {\n        queries.push({\n          name: queryNames[index],\n          conditions: condition,\n          fields: queryFields,\n          orderby: query.queryOrderby as string,\n        });\n      });\n    if (query.title && query.displayType && query.interval && queries.length > 0) {\n      const newWidget: Widget = {\n        ...(pick(query, ['title', 'displayType', 'interval']) as {\n          title: string;\n          displayType: DisplayType;\n          interval: string;\n        }),\n        queries,\n      };\n      return newWidget;\n    }\n  }\n  return undefined;\n}\n"],"names":["Reflux","DashboardWidgetQuerySelectorModal","React","renderQueries","organization","widget","selection","this","props","queries","map","query","index","eventView","eventViewFromWidget","title","displayType","QueryContainer","Container","SearchLabel","htmlFor","t","StyledInput","value","conditions","disabled","OpenInDiscoverButton","priority","icon","size","direction","onClick","browserHistory","getResultsViewUrlTarget","slug","render","Body","Header","closeButton","Input","space","Button","p","theme","border","dropShadowLight","backgroundSecondary","borderRadius","gray300","modalCss","withApi","withGlobalSelection","storeConfig","itemsById","loading","init","reset","listenTo","ProjectActions","onAddTeam","onChangeSlug","onCreateSuccess","loadInitialData","onStatsLoadSuccess","onRemoveTeam","onUpdateSuccess","TeamActions","onDeleteTeam","items","reduce","project","id","trigger","Set","Object","keys","prevSlug","newSlug","prevProject","getBySlug","newProject","data","getById","assign","touchedIds","entries","forEach","projectId","stats","push","teamSlug","projectIds","getWithTeam","projectWithTeam","removeTeamFromProject","projectSlug","team","teams","newTeams","filter","getAll","find","values","sort","a","b","getBySlugs","slugs","includes","getState","projects","teamStoreConfig","initialized","state","hasMore","onRemoveSuccess","localeCompare","item","itemId","response","findIndex","get","toString","persistInFlight","api","providedApi","localApi","useRef","undefined","current","Client","handleCleanup","clear","useEffect","WrappedComponent","options","WithApi","propsApi","useApi","displayName","getDisplayName","WithProjects","ProjectsStore","setState","componentWillUnmount","unsubscribe","loadingProjects","DisplayType","DashboardState","cloneDashboard","dashboard","cloneDeep","widgetType","start","end","period","statsPeriod","datetime","environments","fields","EventView","name","version","orderby","range","getUtcDateString","environment","coerceStringToArray","constructWidgetFromQuery","queryNames","queryConditions","queryFields","queryOrderby","condition","interval","length","pick"],"sourceRoot":""}