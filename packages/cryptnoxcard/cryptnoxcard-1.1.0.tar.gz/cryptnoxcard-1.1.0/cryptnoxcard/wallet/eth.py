# -*- coding: utf-8 -*-
"""
A basic Ethereum wallet library
"""
from enum import Enum
from typing import (Any, Dict)

import ecdsa
from cryptnoxpy import Derivation
from eth_account._utils.legacy_transactions import encode_transaction, \
    serializable_unsigned_transaction_from_dict
from eth_utils.curried import keccak
from hexbytes import HexBytes
from web3 import Web3

from . import validators

try:
    from lib import cryptos
    from enums import EthNetwork as Network
except ImportError:
    from ..lib import cryptos
    from ..enums import EthNetwork as Network


def address(public_key: str) -> str:
    return keccak(hexstr=("0x" + public_key[2:]))[-20:].hex()


def checksum_address(public_key: str) -> str:
    return Web3.toChecksumAddress(address(public_key))


def convert_values(sanitized_transaction: Dict) -> Dict:
    """
    Convert values to wei/gwei

    :param sanitized_transaction: Passed transaction
    :return: Dictionary with values in wei
    """
    sanitized_transaction["gasPrice"] = Web3.toWei(
        sanitized_transaction["gasPrice"], "gwei")
    sanitized_transaction["value"] = Web3.toWei(
        sanitized_transaction["value"], "wei")

    return sanitized_transaction


class Web3Api:
    def __init__(self, card, network: Network, api_key: str = ""):
        """

        :param network: str
        """
        if not isinstance(network, Network):
            network = Network[network.upper()]
        self.card = card
        self.network = network
        self.api_key = api_key

    def get_domain(self) -> str:
        """
        Returns domain used by api

        :return: String containing domain name
        """
        return f"{self.network.name.lower()}.infura.io/v3"

    def get_web3(self) -> Web3:
        """
        Get API url depending on network.

        :return: Web3 object
        """
        # TODO: hide API key
        return Web3(Web3.HTTPProvider(f"https://{self.get_domain()}/{self.api_key}"))
#                                      f"49051ea63cff40d990bf1db642cfcf58"))

    def get_transaction_count(self, address: str, blocks: str = "") -> int:
        return self.get_web3().eth.get_transaction_count(
            Web3.toChecksumAddress(address), blocks)

    def get_balance(self, address: str) -> float:
        """

        :param address: str
        :return: float
        """
        return self.get_web3().eth.get_balance(Web3.toChecksumAddress(address))

    @staticmethod
    def _decode_vrs(signature_der: bytes, chain_id: int, transaction: bytes,
                    q_pub: tuple) -> tuple:
        """
        Method used for getting v, r and s values

        :param signature_der: Signature generated by the Cryptnox card
        :param chain_id: Networks chain ID
        :param transaction: Encoded transaction
        :param q_pub: Wallets q_pub
        :return: Tuple containing v, r, s values
        """
        curve = ecdsa.curves.SECP256k1
        signature_decode = ecdsa.util.sigdecode_der
        generator = curve.generator
        var_r, var_s = signature_decode(signature_der, generator.order())

        # Parity recovery
        var_q = ecdsa.keys.VerifyingKey.from_public_key_recovery_with_digest(
            signature_der, transaction, curve, sigdecode=signature_decode)[1]

        if var_q.to_string("uncompressed") == \
                cryptos.encode_pubkey(q_pub, "bin"):
            i = 36
        else:
            i = 35
        var_v = 2 * chain_id + i

        return var_v, var_r, var_s

    def transaction_hash(self, transaction: Dict[str, Any]):
        chain_id = self.network.value
        unsigned_transaction = serializable_unsigned_transaction_from_dict(
            transaction)
        encoded_transaction = encode_transaction(unsigned_transaction,
                                                 vrs=(chain_id, 0, 0))
        return keccak(encoded_transaction)

    def push(self, transaction, signature, public_key):
        unsigned_transaction = serializable_unsigned_transaction_from_dict(
            transaction)
        var_v, var_r, var_s = Web3Api._decode_vrs(signature, self.network.value,
                                                  self.transaction_hash(transaction),
                                                  cryptos.decode_pubkey(public_key))

        rlp_encoded = encode_transaction(unsigned_transaction,
                                         vrs=(var_v, var_r, var_s))

        return self.get_web3().eth.send_raw_transaction(HexBytes(rlp_encoded))


class EthValidator:
    """
    Class defining Ethereum validators
    """
    network = validators.EnumValidator(Network)
    price = validators.IntValidator(min_value=0)
    limit = validators.IntValidator(min_value=0)
    derivation = validators.EnumValidator(Derivation)
    api_key = validators.AnyValidator()

    def __init__(self, network: str = "ropsten", price: int = 8, limit: int = 2500,
                 derivation: str = "DERIVE", api_key=""):
        self.network = network
        self.price = price
        self.limit = limit
        self.derivation = derivation
        self.api_key = api_key
