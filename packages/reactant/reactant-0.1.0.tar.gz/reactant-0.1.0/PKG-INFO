Metadata-Version: 2.1
Name: reactant
Version: 0.1.0
Summary: Generate code for models, views, and urls based on Python type annotations.
License: MIT
Author: Neil Van
Author-email: nvq.alino@gmail.com
Requires-Python: >=3.8,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Requires-Dist: Jinja2 (>=3.0.1,<4.0.0)
Requires-Dist: black (>=21.8b0,<22.0)
Requires-Dist: click (>=8.0.1,<9.0.0)
Requires-Dist: pydantic (>=1.8.2,<2.0.0)
Description-Content-Type: text/markdown

<p align="center">
    <a href="#">
        <img width="1200" src="https://raw.githubusercontent.com/neil-vqa/reactant/main/reactant-logo-banner.png">
    </a>
</p>

Generate code for *models, views, and urls* based on Python type annotations. Powered by [pydantic](https://github.com/samuelcolvin/pydantic/). Influenced by [SQLModel](https://github.com/tiangolo/sqlmodel).

*reactant* aims to be non-intrusive and disposable, but also to give usable and sensible code defaults.

*reactant* does **not enforce** a particular application structure. Instead, it adheres to the default/minimal/common structure of the supported frameworks, and it is up to the developer to make use of the generated code to fit it to their application. Contibutions are warmly welcomed if you believe a particular structure is widely used and can benefit from code generation.

## Supported Frameworks

*reactant* currently generates code for the following:

**Django REST** (in Django's *default* project structure i.e. by *apps*)

- [X] models
- [X] views (class-based API views, filename=*views_class.py*)
- [ ] views (function-based API views, filename=*views_function.py*)
- [X] serializers
- [X] urls (from class-based API views, filename=*urls_class.py*)
- [ ] urls (from function-based API views, filename=*urls_function.py*)

**SQLAlchemy**

- [ ] models in Declarative Mapping

**Peewee**

- [ ] models

## Installation

```cli
$ pip install reactant
```

## Get Started

Create *reactant* models by inheriting from `Reactant` , and from choosing an ORM: `DjangoORM`, `SQLAlchemyORM`, `PeeweeORM`. The example below uses `DjangoORM`. Your choice of ORM will determine what code and files will be generated.

```python
# generate.py

from reactant import Reactant, DjangoORM, Field, generate


class RocketEngine(Reactant, DjangoORM):
    name: str = Field(max_length=32, title="engine_name")
    manufacturer: str = Field(max_length=64)
    power_cycle: Optional[str] = Field("gas-generator", blank=True, max_length=32)
    thrust_weight_ratio: Optional[int] = None


class LaunchVehicle(Reactant, DjangoORM):
    name: str = Field(max_length=32)
    country: str = Field(blank=True, max_length=32)
    status: str
    total_launches: Optional[int]
    engine: str = Field(foreign_key="RocketEngine")

# Don't forget this block.
if __name__ == "__main__":
    generate()

```

Don't forget `generate()`. Run the code. 

```cli
$ reactant generate.py

Running generate.py
Found 2 Django reactants.
Django models.py finished rendering.
Django views_class.py finished rendering.
Django serializers.py finished rendering.
Django urls_class.py finished rendering.
Success! Please check "reactant_products" directory.
```

**BOOM!** With just the above code, the models, views, serializers, and urls (the *products*, for Django atleast) are generated.

## Development

The project uses Poetry to package and manage dependencies.

```cli
(venv)$ poetry install
```

Run tests.
```cli
pytest
```

## License

MIT License. For more information and legal terms, see the LICENSE file.
