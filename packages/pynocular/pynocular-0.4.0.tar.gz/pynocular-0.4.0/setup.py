# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pynocular']

package_data = \
{'': ['*']}

install_requires = \
['SQLAlchemy>=1.3.19',
 'aenum>=2.1,<3.0',
 'aiocontextvars==0.2.2',
 'aiopg==0.16.0',
 'asyncpg==0.15.0',
 'asyncpgsa==0.23.0',
 'backoff==1.10.0',
 'pydantic>=1.6,<2.0']

setup_kwargs = {
    'name': 'pynocular',
    'version': '0.4.0',
    'description': 'Lightweight ORM that lets you query your database using Pydantic models and asyncio',
    'long_description': '# pynocular\n\n[![](https://img.shields.io/pypi/v/pynocular.svg)](https://pypi.org/pypi/pynocular/) [![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)\n\nPynocular is a lightweight ORM that lets you query your database using Pydantic models and asyncio.\n\nWith Pynocular you can decorate your existing Pydantic models to sync them with the corresponding table in your\ndatabase, allowing you to persist changes without ever having to think about the database. Transaction management is\nautomatically handled for you so you can focus on the important parts of your code. This integrates seamlessly with frameworks that use Pydantic models such as FastAPI.\n\nFeatures:\n\n- Fully supports asyncio to write to SQL databases\n- Provides simple methods for basic SQLAlchemy support (create, delete, update, read)\n- Contains access to more advanced functionality such as custom SQLAlchemy selects\n- Contains helper functions for creating new database tables\n- Advanced transaction management system allows you to conditionally put requests in transactions\n\nTable of Contents:\n\n- [Installation](#installation)\n- [Guide](#guide)\n  - [Basic Usage](#basic-usage)\n  - [Advanced Usage](#advanced-usage)\n  - [Creating database tables](#creating-database-tables)\n- [Development](#development)\n\n## Installation\n\npynocular requires Python 3.6 or above.\n\n```bash\npip install pynocular\n# or\npoetry add pynocular\n```\n\n## Guide\n\n### Basic Usage\n\nPynocular works by decorating your base Pydantic model with the function `database_model`. Once decorated\nwith the proper information, you can proceed to use that model to interface with your specified database table.\n\nThe first step is to define a `DBInfo` object. This will contain the connection information to your database.\n\n```python\nfrom pynocular.engines import DatabaseType, DBInfo\n\n\n# Example below shows how to connect to a locally-running Postgres database\nconnection_string = f"postgresql://{db_user_name}:{db_user_password}@localhost:5432/{db_name}?sslmode=disable"\n)\ndb_info = DBInfo(DatabaseType.aiopg_engine, connection_string)\n```\n\nPynocular supports connecting to your database through two different asyncio engines; aiopg and asyncpgsa.\nYou can pick which one you want to use by passing the correct `DatabaseType` enum value into `DBInfo`.\n\nOnce you define a `db_info` object, you are ready to decorate your Pydantic models and interact with your database!\n\n```python\nfrom pydantic import BaseModel, Field\nfrom pynocular.database_model import database_model, UUID_STR\n\n\n@database_model("organizations", db_info)\nclass Org(BaseModel):\n\n    id: Optional[UUID_STR] = Field(primary_key=True, fetch_on_create=True)\n    serial_id: Optional[int]\n    name: str = Field(max_length=45)\n    slug: str = Field(max_length=45)\n    tag: Optional[str] = Field(max_length=100)\n\n    created_at: Optional[datetime] = Field(fetch_on_create=True)\n    updated_at: Optional[datetime] = Field(fetch_on_update=True)\n\n\n# Create a new Org via `create`\norg = await Org.create("new org", "new-org")\n\n\n# Create a new Org via `save`\norg2 = Org("new org2", "new-org2")\nawait org2.save()\n\n\n# Update an org\norg.name = "renamed org"\nawait org.save()\n\n\n# Delete org\nawait org.delete()\n\n\n# Fetch org\norg3 = await Org.get(org2.id)\nassert org3 == org2\n\n# Fetch a list of orgs\norgs = await Org.get_list()\n\n# Fetch a filtered list of orgs\norgs = await Org.get_list(tag="green")\n\n#  Fetch orgs that have several different tags\norgs = await Org.get_list(tag=["green", "blue", "red"])\n```\n\nWith Pynocular you can set fields to be optional and set by the database. This is useful\nif you want to let the database autogenerate your primary key or `created_at` and `updated_at` fields\non your table. To do this you must:\n\n- Wrap the typehint in `Optional`\n- Provide keyword arguments of `fetch_on_create=True` or `fetch_on_update=True` to the `Field` class\n\n### Advanced Usage\n\nFor most use cases, the basic usage defined above should suffice. However, there are certain situations\nwhere you don\'t necessarily want to fetch each object or you need to do more complex queries that\nare not exposed by the `DatabaseModel` interface. Below are some examples of how those situations can\nbe addressed using Pynocular.\n\n#### Batch operations on tables\n\nSometimes you want to insert a bunch of records into a database and you don\'t want to do an insert for each one.\nThis can be handled by the `create_list` function.\n\n```python\norg_list = [\n    Org(name="org1", slug="org-slug1"),\n    Org(name="org2", slug="org-slug2"),\n    Org(name="org3", slug="org-slug3"),\n]\nawait Org.create_list(org_list)\n```\n\nThis function will insert all records into your database table in one batch.\n\nIf you have a use case that requires deleting a bunch of records based on some field value, you can use `delete_records`:\n\n```python\n# Delete all records with the tag "green"\nawait Org.delete_records(tag="green")\n\n# Delete all records with if their tag has any of the following: "green", "blue", "red"\nawait Org.delete_records(tag=["green", "blue", "red"])\n```\n\nSometimes you may want to update the value of a record in a database without having to fetch it first. This can be accomplished by using\nthe `update_record` function:\n\n```python\nawait Org.update_record(\n    id="05c0060c-ceb8-40f0-8faa-dfb91266a6cf",\n    tag="blue"\n)\norg = await Org.get("05c0060c-ceb8-40f0-8faa-dfb91266a6cf")\nassert org.tag == "blue"\n```\n\n#### Complex queries\n\nSometimes your application will require performing complex queries, such as getting the count of each unique field value for all records in the table.\nBecause Pynocular is backed by SQLAlchemy, we can access table columns directly to write pure SQLAlchemy queries as well!\n\n```python\nfrom sqlalchemy import func, select\nfrom pynocular.engines import DBEngine\nasync def generate_org_stats():\n    query = (\n        select([func.count(Org.column.id), Org.column.tag])\n        .group_by(Org.column.tag)\n        .order_by(func.count().desc())\n    )\n    async with await DBEngine.transaction(Org._database_info, is_conditional=False) as conn:\n        result = await conn.execute(query)\n        return [dict(row) async for row in result]\n```\n\nNOTE: `DBengine.transaction` is used to create a connection to the database using the credentials passed in.\nIf `is_conditional` is `False`, then it will add the query to any transaction that is opened in the call chain. This allows us to make database calls\nin different functions but still have them all be under the same database transaction. If there is no transaction opened in the call chain it will open\na new one and any subsequent calls underneath that context manager will be added to the new transaction.\n\nIf `is_conditional` is `True` and there is no transaction in the call chain, then the connection will not create a new transaction. Instead, the query will be performed without a transaction.\n\n### Creating database tables\n\nWhen you decorate a Pydantic model with Pynocular, it creates a SQLAlchemy table as a private variable. This can be accessed via the `_table` property\n(although accessing private variables is not recommended). Using this, along with Pynocular\'s `create_tracked_table` function, allows you to create tables\nin your database based off of Pydantic models!\n\n```python\nfrom pynocular.db_utils import create_tracked_table\n\nfrom my_package import Org\n\n# Creates the table "organizations" in the database defined by db_info\nawait create_tracked_table(Org._database_info, Org._table)\n\n```\n\n## Development\n\nTo develop pynocular, install dependencies and enable the pre-commit hook:\n\n```bash\npip install pre-commit poetry\npoetry install\npre-commit install\n```\n\nTo run tests:\n\n```bash\npoetry run pytest\n```\n',
    'author': 'RJ Santana',
    'author_email': 'ssantana@narrativescience.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/NarrativeScience/pynocular',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6.5,<4.0.0',
}


setup(**setup_kwargs)
