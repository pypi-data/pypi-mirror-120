# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['protopy',
 'protopy.cli',
 'protopy.cli.commands',
 'protopy.cli.sources',
 'protopy.cli.utils']

package_data = \
{'': ['*'], 'protopy.cli': ['resources/templates/*']}

install_requires = \
['protopy_lib>=0.2.0,<0.3.0',
 'pygit2>=1.6.1,<2.0.0',
 'requests>=2.26.0,<3.0.0',
 'tomlkit>=0.7.2,<0.8.0']

extras_require = \
{':python_version < "3.8"': ['typing-extensions>=3.10.0.2,<4.0.0.0',
                             'importlib-resources>=5,<6'],
 ':python_version >= "3.6" and python_version < "3.7"': ['dataclasses>=0.8']}

entry_points = \
{'console_scripts': ['protopy = protopy.application:main']}

setup_kwargs = {
    'name': 'protopy-cli',
    'version': '0.2.0',
    'description': '',
    'long_description': '# Protopy\n\nA library and CLI for rendering directory trees.\n\nIt is composed of two projects:\n\n- A command-line utility that creates scaffolding for files and projects from templates.\n- A library that allows for embedding into other applications with minimal dependencies\n\n## How does it work\n\nA protopy template is a directory which contains at least a `proto.py` file. Inside this directory, we create the\ndirectory tree to be copied into the generated path. Protopy uses [jinja](https://jinja.palletsprojects.com/en/3.0.x/)\nto render its templates, the rendering happens both on the file/dir names and inside any file that ends with `.tmpl`.\n\n## Example\n\nThe following is the directory structure of a template we will use as our example.\n\n```\nour-template/\n├── {{project_name}}\n│\xa0\xa0 ├── {{readme_file_name}}\n│\xa0\xa0 ├── src\n│\xa0\xa0 │\xa0\xa0 └── main.py\n│\xa0\xa0 └── {{tests_dir}}\n└── proto.py\n```\n\nNote that we have a directory named `{{project_name}}` and a file named `{{readme_file_name}}` (yes, the file and\ndirectory names include the double-curly-braces, just as you see them here), This means that this template\nexpects `proto.py` to define at least those variables.\n\nHere is an example content for `proto.py`:\n\n```python\n# this is the main template logic.\n# after the execution of this file, the module variables will be visible to the renderer of the directory tree to be copied into the generated path. \n\n# you can ask the user for input like the following, which results in the prompt:  "> Project Name:"\n# the \'project_name\' also represents the name of a commandline variable, we will see more about it down this example \nproject_name = ask(\'project_name\')\n\n# you can also set default and explicit prompt\nauthor = ask(\'author\', prompt=\'Who are you?\', default="no one")\n\n# you can restrict input to a set of choices\nreadme_type = ask(\'readme_type\', prompt=\'What Type of README file would you like?\', default=0,\n                  choices=["Markdown", "reStructuredText"])\n\n# you can create module variables like any python module - you don\'t have to ask for them.. \nif readme_type == "Markdown":\n    readme_file_name = "README.md.tmpl"\nelse:\n    readme_file_name = "README.rst.tmpl"\n\n# you can ask for yes/no confirmation like this:\ntests_dir = ""\nif confirm("use_tests", prompt="Would you like a tests directory?"):\n    tests_dir = "tests"\n\n# when calling from the commandline the user can supply named args and positional args,\n# in the example below, if the user executed protopy with either the commands:\n# > protopy <your template name> "My Protopy-Generated Project"\n# > protopy <your template name> description="My Protopy-Generated Project"\n# then the user will not get any prompt and the value "My Protopy-Generated Project" will be returned \ndescription = ask(\'description\', positional_arg=0)\n\n# you can print additional information to the user using the say command, it supports terminal formatting (read the doc for more info): \nsay("<info>Done configuring and start generating!</info>")\n\n\n# finally you can optionally define a post generation hook\ndef post_generation():\n    say("<info>Done generating!</info>")\n\n# Check out the docs for more information..\n```\n\nNotice the file named `{{readme_file_name}}` in the directory structure, this file gets its value inside `proto.py`. It has\n2 possible values `README.md.tmpl` and `README.rst.tmpl`, since the file extension is `tmpl` its content will be\nrendered using `jinja`.\n\nHere is an example content of the `{{readme_file_name}}` file:\n\n```markdown\n# {{project_name}}\n\n> Created By {{author}}\n\n{{description}}\n```\n\nNext, we can see that there is a directory named `{{tests_dir}}` in our template, by examining the `proto.py` file we\ncan see that the `tests_dir` variable can be empty, this will result in a file/directory without a name in the rendering\nphase which will cause the file/dir to not be rendered (in other words the `{{tests_dir}}` directory may not exist).\n\nFinally we can generate a project based on this template via:\n\n```console\n> protopy generate our-template output-dir project_name="example"\nWho are you? [no one] > John            \nWhat Type of README file would you like? [Markdown]:\n [0] Markdown\n [1] reStructuredText\n > \nWould you like a tests directory? (yes/no) [yes] no\nDescription > our example description\nDone configuring and start generating! \nDone generating! \n```\n\nNotice that the user was not asked about the Project name as we supplied it in the commandline. The resulted content\nof `output-dir` is:\n\n```\n.\n└── example\n    ├── README.md\n    └── src\n        └── main.py\n```\n\nand the content of README.md is:\n\n```markdown\n# example\n\n> Created By John\n\nour example description\n```\n\n## CLI Commands\n\nProtopy supports the following commands:\n\n### New\n\n```\nDescription:\n  create a new template (and populate it with some example content)\n\nUsage:\n  protopy new [<out_dir>]\n\nArguments:\n  out_dir   directory to create the template in, defaults to the current directory\n\n```\n\n### Generate\n\n```\nDescription:\n  generate directory tree based on a given template\n\nUsage:\n  protopy generate <template> <output_path> [<template_args>...]\n\nArguments:\n  template              the template to use (supports path, git, zip and url to zip)\n  output_path           where to put the generated content\n  template_args         template arguments, can be positional and key=value\n\nOptions:\n  -o, --overwrite       allows the generated content to overwrite existing files\n\n```\n\nThe `generate` command support generating templates from different sources:\n\n- Local directory: `protopy generate /path/to/dir ...`\n- Local zip file: `protopy generate /path/to/zip/file.zip ...`\n- Remote zip file: `protopy generate https://url-to-zip-file.zip ...`\n- Git repository: `protopy generate git+https://github.com/...`\n\n### Manual _(man)_\n\n```\nDescription:\n  print information about a template\n\nUsage:\n  protopy man [options] [--] <template>\n\nArguments:\n  template              the template to examine (supports path, git, zip, url to zip)\n\n\n```\n\n\n## The `proto.py` file\n\nThe `proto.py` file executes before the directory tree generation starts. Any (module level) variable that is defined\nin `proto.py` will then be available to the `jinja` templates in the generation process. After the generation completes,\nif `proto.py` defined a module level `post_generation` function it will be called.\n\nDuring its execution, `proto.py` has several special methods that are supplied to it by protopy:\n\n```python\n\ndef ask(self, named_arg: str, *, prompt: str = None, default: Any = "", choices: Optional[List[str]] = None,\n        autocomplete: Optional[List[str]] = None, secret: bool = False, positional_arg: int = -1,\n        doc: str = ""):\n\n    """\n    ask the user for information (either retrieving it from the command line or from the user supplied arguments)\n    :param named_arg: the name of the argument that may contain the value for this function to return\n    :param prompt: (optional - defaults to a string generated from named_arg) the prompt to show to the user\n    :param default: (optional - defaults to None) the default value to suggest the user\n    :param choices: (optional - defaults to None) list of choices to restrict the user input to\n    :param autocomplete: (optional - defaults to None) list of autocomplete suggestions to help the user with\n    :param secret: (optional - defaults to False) set to True to hide the user input\n    :param positional_arg:  (optional - defaults to -1) the index of the positional argument that may contain the\n                            value for this function to return\n    :param doc: documentation to show in the commandline (must be a string literal)\n\n    :return: the requested user input\n    """\n\n\ndef confirm(\n        self, named_arg: str, *, prompt: str, doc: str = "", default: bool = True, positional_arg: int = -1) -> bool:\n\n    """\n    ask the user for yes/no confirmation (either retrieving it from the command line or from the user supplied arguments)\n    :param named_arg: the name of the argument that may contain the value for this function to return (supports the values y,yes,n,no)\n    :param prompt: (optional - defaults to a string generated from named_arg) the prompt to show to the user\n    :param default: (optional - defaults to True = \'yes\') the default value to suggest the user\n    :param positional_arg: (optional - defaults to -1) the index of the positional argument that may contain the\n                            value for this function to return\n    :param doc: documentation to show in the commandline (must be a string literal)\n    :return: True if the user confirmed or False otherwise\n    """\n\n\ndef arg(self, named_arg: str, *, doc: str = "", default: str = "", positional_arg=-1):\n    """\n    fetch a value from the commandline arguments, without asking the user for it if not provided\n    :param named_arg: the name of the argument that may contain the value for this function to return (supports the values y,yes,n,no)\n    :param doc: documentation to show in the commandline (must be a string literal)\n    :param default: (optional - defaults to None) the default value to suggest the user\n    :param positional_arg:  (optional - defaults to -1) the index of the positional argument that may contain the\n                            value for this function to return\n    :return: the requested user value\n    """\n\n\ndef say(msg: str):\n    """\n    display a message to the user\n    :param msg: the message to display \n    """\n\n```\n\nInternally, Protopy uses [cleo](https://github.com/sdispater/cleo) for terminal IO, therefore all prompts support output\ncoloring. You can read about it [here](https://cleo.readthedocs.io/en/latest/introduction.html#coloring-the-output), but\nhere is the gist of it:\n\n```python\n# Use predefined colors.\nsay(\'<info>hi there</info>\')\nsay(\'<comment>hi there</comment>\')\nsay(\'<question>hi there</question>\')\nsay(\'<error>hi there</error>\')\n\n# Define your own colors.\n# Available foreground and background colors are: black, red, green, yellow, blue, magenta, cyan and white.\n# And available options are: bold, underscore, blink, reverse and conceal.\nsay(\'<fg=green>hi there</>\')\nsay(\'<fg=black;bg=cyan>hi there</>\')\nsay(\'<bg=yellow;options=bold>hi there</>\')\n```\n\n## Advanced Templating\n\n### Excluding files\n\nSometimes, your template may contain files that you want to exclude from the rendering process. You can use\na `.protopyignore` file for that (just add glob patterns to it similar to `.gitignore` file)\n\n### Copying content without templating \n\nSometimes, your template may contain directories that you want to copy as is (without passing through the template engine).\nTo do so, all you need to do is to include a `.protopypreserve` file inside the directory that you want to preserve as is.\n\n\n### Dynamic file positioning\n\nWhen generating file/dir names, you can give the file a name that includes a relative path and the file will be\nrelocated into this path during the generation process.\n\nFor example, For a template structure:\n\n```\ndynamic-template/\n├── {{dynamically_positioned_file}}\n└── proto.py\n```\n\nAnd a proto.py file:\n\n```python\n# proto.py\ndynamically_positioned_file = "some/nested/directory/file.txt"\n```\n\nrunning the command\n\n```console\n> protopy generate dynamic-template out-dir\n```\n\nwill result with the directory structure:\n\n```\nout-dir/\n└── some\n    └── nested\n        └── directory\n            └── file.txt\n```\n\n## The Protopy library (`protopy-lib`)\n\nThe Protopy library (protopy_lib) includes the Protopy engine itself without the commandline and support for multiple\ntemplate sources. It has minimal set of dependencies and is intended for embedding inside other applications.\n\nit exposes the following class:\n\n```python\n\nclass ProtopyEngine:\n    def render_doc(self, template_dir: Union[Path, str], template_descriptor: Optional[str] = None,\n                   command_prefix: str = "protopy") -> str:\n        """\n        :param the directory holding the template\n        :param template_descriptor: the descriptor that used to resolve the template directory, if not provided,\n                                    the template directory will be considered as the descriptor\n        :param command_prefix: the prefix of the commandline that should be used to generate this template\n        :return: a generated documentation for this template\n        """\n\n    def render(self, template_dir: Union[Path, str], target_dir: Union[Path, str],\n               args: List[str], kwargs: Dict[str, str], extra_conte~~~~xt: Dict[str, Any], *,\n               excluded_files: Optional[List[Path]] = None, allow_overwrite: bool = False):\n        """\n        renders the given template into the target directory\n\n        :param template_dir: the directory holding the template\n        :param target_dir: the directory to output the generated content into\n        :param args: positional arguments for the template\n        :param kwargs: named arguments for the template\n        :param extra_context: extra variables that will be available inside proto.py\n        :param excluded_files:  list of path objects that represents files in the template directory that should be\n                                excluded from the generation process\n        :param allow_overwrite: if True, files that are already exists will be overridden by the template\n        """\n\n```\n\n## Comparison to other tools\n\nProtopy is very similar in concept to [cookiecutter](https://github.com/cookiecutter/cookiecutter)\nand [copier](https://github.com/copier-org/copier/) but has the following differences:\n\n- No configuration, instead a regular python code is being used.\n- Composed of two parts - library and cli to support embedding without unneeded dependencies\n- Does not directly support template updates \n- Allows for dynamic file positioning, as it intended to be used both for generating projects and also scaffolding\n  software components\n\n## How to build this project\nThis project is built using [relaxed-poetry](https://github.com/bennylut/relaxed-poetry)\n',
    'author': 'bennylut',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'entry_points': entry_points,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
