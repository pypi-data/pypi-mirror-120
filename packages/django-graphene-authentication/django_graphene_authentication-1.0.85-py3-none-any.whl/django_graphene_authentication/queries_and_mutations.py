import abc
import functools
from calendar import timegm
from datetime import datetime, timedelta
from typing import Dict, Tuple, Callable, Union, List, Optional

import graphene
import jwt
import stringcase
import logging
from django.conf import settings
from django.contrib.auth import authenticate, get_user
from django_koldar_utils.django_toolbox import auth_decorators
from django_koldar_utils.graphql_toolsbox.GraphQLHelper import GraphQLHelper
from graphene.types.generic import GenericScalar
from graphene.utils.thenables import maybe_thenable

from django_graphene_authentication import decorators
from django_graphene_authentication.decorators import get_refresh_expiration_decorator, get_csrf_rotation_decorator
from django_graphene_authentication.models import StandardRefreshToken
from django_graphene_authentication.utils import get_authenticating_token

LOG = logging.getLogger(__name__)


class AbstractGrapheneMutationCreator(abc.ABC):
    """
    Abstract class that allows you to define a graphene authentication endpoint.

    This class generates mutation that will perform certain tasks:

     - login: a login mutation that allows you to gain access to an "authenticate" call. It's up to you what you want to
        do with such call. This means that you need to set your authentication backend correctly
     - me: a query that fetches the currently logged user.
    """

    def __init__(self):
        self.me_query_actual_output_name = ""

    def login_mutation_class_name(self, context) -> str:
        return f"{context}Login"

    def login_mutation_description(self, context, mutation_class_name: str) -> str:
        return f"Allows you to authenticate the user for {context}"

    def login_required_decorator(self) -> Callable[[Callable], Callable]:
        """
        Function that yields a decorator used to check if the the user invoking a graphql resolver is authenticated or not.
        Usuaally login_required
        :return:
        """
        return auth_decorators.graphql_ensure_login_required()

    def permissions_required_decorator(self) -> Callable[[Union[List[str], str]], any]:
        """
        Function that yields a decorator used to check if the the user invoking a graphql resolver has the right permissions or not.
        Usuaally has_perm
        :return:
        """
        return auth_decorators.graphql_ensure_user_has_permissions

    @abc.abstractmethod
    def get_user(self, root, info, request, *args, **kwargs):
        """
        Fetch the user from the request
        :param root: graphql root in path
        :param info: graphql info in path
        :param request: graphql request
        :param args:
        :param kwargs:
        :return:
        """
        pass

    @abc.abstractmethod
    def _login_mutation_arguments(self, context) -> Dict[str, any]:
        """
        Generate a dictioanry of graphene data. The data is passed as mutations arguments, as is
        :param context: shared context whiel creating graphql endpoints
        :return: login mutation arguments.
        """
        pass

    @abc.abstractmethod
    def _login_mutation_return_type(self, context) -> Dict[str, any]:
        """
        The list of return values generated by the login mutation
        :param context: context shared while generating the login class
        :return:
        """
        pass

    def _on_before_authenticate(self, mutation_instance, info, additional_fields, *args, **kwargs):
        """
        Do some action just before performing the authenticate django call.
        By default we set a field that can be used to determine if the django default authenticate mechanism that
        we will call afterwards has been called from the login mutation or from some other source

        :param mutation_instance: graphql root
        :param info: graphql info
        :param additional_fields: a dictionary that is injected in the django authenticate call
        :param args: graphql args
        :param kwargs: graphql kwargs
        """
        # We are trying to authenticate via a login mutation
        info.context.are_we_authenticating_from_login_mutation = True

    @abc.abstractmethod
    def _get_authenticate_additional_fields(self, mutation_instance, info, *args, **kwargs) -> Dict[str, any]:
        """
        A dictioanry that is passed to the django authenticate mechanism. In this way you can put to the authenticate
        call additional reuired fields.

        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        """
        pass

    def _perform_authentication(self, mutation_instance, info, *args, **kwargs) -> any:
        """
        Perform the authentication by relayng graphql information to the authentication backend. Usually called by
        login_mutation_body
        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return: the user authenticated
        :raises Exception: if the user cannot be authenticated
        """
        request = info.context

        additional_fields = self._get_authenticate_additional_fields(mutation_instance, info, *args, **kwargs)
        self._on_before_authenticate(mutation_instance, info, additional_fields, *args, **kwargs)
        # Call django to authenticate the user
        user = authenticate(
            root=mutation_instance,
            request=request,
            info=info,
            *args,
            **kwargs,
            **additional_fields,
        )
        if user is None:
            self.authentication_failed(mutation_instance, info, *args, **kwargs)
        request.authenticated_user = user
        request.user = user
        return user

    @abc.abstractmethod
    def _on_login_mutation_output_computed(self, user, root, info, result, *args, **kwargs):
        """
        Code to do when we have generate the output of the login mutation. Performed only if the
        authentication succeeds
        :param user: user authenticated
        :param root: graphql root
        :param info: gfraphql info
        :param result: output of ht elogin mutation
        :param args: graphql *args
        :param kwargs: graphql **kwargs
        """
        pass

    @abc.abstractmethod
    def login_generate_mutation_output(self, user, mutation_instance, info, *args, **kwargs):
        """
        Function that is used to generate an instance of the muitation class. Needed in the mutate
        method
        :param user: the user just authenticated
        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return:
        """
        pass

    def login_mutation_body(self, mutation_instance: any, info, *args, **kwargs) -> any:
        """
        Actual body of the mutation login. You should not directly override this method, but rely
        on _perform_authentication, _login_generate_mutation_output and _on_login_mutation_output_computed
        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return:
        """
        LOG.info(f"Authenticating user via {mutation_instance}...")
        user = self._perform_authentication(mutation_instance, info, *args, **kwargs)
        LOG.info(f"Authenticated user is {user}")
        result = self.login_generate_mutation_output(user, mutation_instance, info, *args, **kwargs)
        LOG.info(f"output of {mutation_instance} is {result}")

        # now generate the payload
        return maybe_thenable((user, mutation_instance, info, result, args, kwargs),
                              lambda values: self._on_login_mutation_output_computed(*values))

    def authentication_failed(self, root, info, *args, **kwargs):
        raise ValueError(f"Authentication failed.")

    def me_query_class_name(self, context) -> str:
        return f"{context}Login"

    def me_query_description(self, context, mutation_class_name: str) -> str:
        return f"Allows you to detect which user is authenticated via the specified arguments for context {context}"

    @abc.abstractmethod
    def me_query_arguments(self, context) -> Dict[str, any]:
        """
        Graphene dicitonaries of arguments required to run the "me" graphql query
        :param context: shared object used when creating the login queries and mutations
        :return:
        """
        pass

    @abc.abstractmethod
    def me_query_return_type(self, context) -> any:
        """
        The single value returned by the me query. Usually it is just the authenticated user
        :param context: shared object used when creating the login queries and mutations
        :return:
        """
        pass

    @abc.abstractmethod
    def me_query_return_value_name(self, context) -> any:
        """
        Name of the single value returned by the me query. Usually "user"
        :param context: shared object used when creating the login queries and mutations
        :return:
        """
        pass

    def _fetch_currently_logged_user_in_me_query(self, query_instance: any, info, *args, **kwargs) -> any:
        """
        Overwriteable. Allows you to determine how you want to fech the user when a /me graphql endpoint is invoked.
        By default we wlook at the already authenticated user

        :param query_instance:
        :param info: graphql query info object, as passed by graphene
        :param args: graphql query args object, as passed by graphene
        :param kwargs: graphql query kwargs object, as passed by graphene
        :return:
        """
        request = info.context
        return request.user

    def me_query_body(self, query_instance: any, info, *args, **kwargs) -> any:
        """
        Code that will be executed whenever the /me query is performed

        :param root: graphql rooquery
        :param info: grpahql query info object
        :param args:  graphql query args
        :param kwargs: graphql query kwargs
        :return: the same type you have chosen in me_query_return_type
        """
        user = self._fetch_currently_logged_user_in_me_query(query_instance, info, *args, **kwargs)
        return user

    @abc.abstractmethod
    def get_permissions_required_to_me_query(self, context) -> Union[str, List[str]]:
        """
        permissions that are required in order to gain access to the me query
        :param context: shared object used when creating the login queries and mutations
        :return:
        """
        pass

    @abc.abstractmethod
    def generate_context(self) -> any:
        """
        Callback where you can add all stuff you want to further inject custom data in the mutation/qwuery in authenticated
        graphql calls. It is call once.
        :return:
        """
        pass

    def generate_queries_and_mutations(self) -> Tuple[type, type]:
        context = self.generate_context()
        login = self._generate_login(context)
        me = self._generate_me(context)

        return login, me

    def _generate_login(self, context) -> type:
        mutation_class_name = self.login_mutation_class_name(context)

        auth_token = GraphQLHelper.create_mutation(
            mutation_class_name=mutation_class_name,
            description=self.login_mutation_description(context, mutation_class_name),
            arguments=self._login_mutation_arguments(context),
            return_type=self._login_mutation_return_type(context),
            body=self.login_mutation_body,
        )
        return auth_token

    def _generate_me(self, context) -> type:
        query_me_class_name = self.me_query_class_name(context)
        permissions_required = self.get_permissions_required_to_me_query(context)

        body = self.me_query_body
        body = self.permissions_required_decorator()(permissions_required)(body)
        body = self.login_required_decorator()(body)

        # to send the output namefrom the graphql class generation time to the body of the me query
        # (which is run when executing the query) we set it in a instance field
        self.me_query_actual_output_name = self.me_query_return_value_name(context)

        me = GraphQLHelper.create_query(
            query_class_name=query_me_class_name,
            description=self.me_query_description(context, query_me_class_name),
            arguments=self.me_query_arguments(context),
            return_type=self.me_query_return_type(context),
            output_name=self.me_query_actual_output_name,
            body=body
        )

        return me


class AbstractTokenGeneratorMutationCreator(AbstractGrapheneMutationCreator):
    """
    A graphene graphql mutation that, after authentication, generates a JWT token.

    Nothing is said about the input of the login mutation. We only know that after the successful login,
    the mutation will generate a token. Hence the nae of "token generator"
    """

    @abc.abstractmethod
    def jwt_generated_payload_name(self) -> str:
        """
        name of the payload item in the login mutation
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_generated_refresh_expires_in_name(self) -> str:
        """
        name of the return value of the login mutation used to refresh the token
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_generated_token_name(self) -> str:
        """
        Name of the generated token by the login mutation
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_generated_long_running_refresh_token_name(self) -> str:
        """
        name of the refresh token used for long running operations in the login mutation
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_generated_long_running_refresh_token(self) -> bool:
        """
        If true, we will create the refresh token.
        Creating refresh tokens means that: (1) on the client we need to keep a  cookie storing an identifier of the
        refresh token, (2) on the server we need to store a db table containign therefresh token. Ususally this feature
        is off
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_generated_allow_refresh(self) -> bool:
        pass

    @abc.abstractmethod
    def jwt_generated_audience(self) -> Optional[str]:
        pass

    @abc.abstractmethod
    def jwt_generated_issuer(self) -> Optional[str]:
        pass

    @abc.abstractmethod
    def jwt_generated_token_algorithm(self) -> str:
        pass

    @abc.abstractmethod
    def jwt_generated_token_secret_key(self) -> str:
        """
        symmetric key used to encode the token that the login mutation will create after a successful login

        :return: secret
        """
        pass

    @abc.abstractmethod
    def jwt_generated_token_public_key(self) -> Optional[str]:
        """
        asymmetric key used to decode the token that the login mutation will create after a sucessful login.
        The key is not used if secret is not null

        :return: public key
        """
        pass

    @abc.abstractmethod
    def jwt_generated_token_private_key(self) -> Optional[str]:
        """
        asymmetric key used to encode the token that the login mutation will create after a sucessful login.
        The key is not used if secret is not null

        :return: private key
        """
        pass

    @abc.abstractmethod
    def jwt_generated_reuse_refresh_tokens(self) -> bool:
        pass

    def jwt_generated_refresh_token_model(self) -> type:
        """
        Server side model used to store information about the refresh token.
        :return:
        """
        return StandardRefreshToken

    def jwt_generated_token_expiration_time(self) -> timedelta:
        """
        time after which the token is not valid anymore
        :return:
        """
        return settings.JWT_TOKEN_EXPIRATION_TIME

    @abc.abstractmethod
    def jwt_use_csrf_rotation(self) -> bool:
        pass

    def get_user(self, root, info, request, *args, **kwargs):
        if hasattr(request, "user"):
            return request.user
        if hasattr(request, "authenticated_user"):
            return request.authenticated_user
        raise ValueError(f"No user found")

    def _login_mutation_return_type(self, context) -> Dict[str, any]:
        result = dict()
        result[self.jwt_generated_payload_name()] = GenericScalar(required=True)
        result[self.jwt_generated_token_name()] = graphene.String(required=True)
        result[self.jwt_generated_refresh_expires_in_name()] = graphene.Int(required=True)
        return result

    def _login_mutation_arguments(self, context) -> Dict[str, any]:
        result = super()._login_mutation_arguments(context)
        if self.jwt_generated_long_running_refresh_token():
            result[self.jwt_generated_long_running_refresh_token_name()] = GraphQLHelper.argument_jwt_token()
        return result

    def _on_login_mutation_output_computed(self, user, root, info, mutation_output, *args, **kwargs):
        """
        What do to if the authentiucation successeds? Use this function to agument the mutation output
        :param user: authenticated user
        :param root: graphql root
        :param info: graphql info
        :param mutation_output: instance of a class representing this mutation
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return:
        """
        request = info.context
        payload_login = self._jwt_payload_handle(user, request)
        setattr(mutation_output, self.jwt_generated_payload_name(), payload_login)

        token_login = self._jwt_encode(payload_login, request)
        setattr(mutation_output, self.jwt_generated_token_name(), token_login)

        if self.jwt_generated_long_running_refresh_token():
            request.jwt_refresh_token = self._create_refresh_token(user)
            setattr(mutation_output, self.jwt_generated_long_running_refresh_token_name(),
                    request.jwt_refresh_token.get_token())

        return mutation_output

    def _create_refresh_token(self, user, refresh_token=None) -> any:
        """
        Create an instance of the refresh tokenb
        :param user: user to authentiucate
        :param refresh_token: refresh token that we need to update
        :return:
        """
        if refresh_token is not None and self.jwt_generated_reuse_refresh_tokens():
            refresh_token.reuse()
            return refresh_token
        model_type = self.jwt_generated_refresh_token_model()
        return model_type.objects.create(user=user)

    def _jwt_encode(self, payload, context=None):
        return jwt.encode(
            payload,
            self.jwt_generated_token_private_key() or self.jwt_generated_token_secret_key(),
            self.jwt_generated_token_algorithm(),
        )

    def _jwt_payload_handle(self, user, request):
        username = user.get_username()

        if hasattr(username, 'pk'):
            username = username.pk

        exp = datetime.utcnow() + self.jwt_generated_token_expiration_time()

        payload = {
            'sub': user.id,
            user.USERNAME_FIELD: username,
            'exp': timegm(exp.utctimetuple()),
        }

        if self.jwt_generated_allow_refresh():
            payload['origIat'] = timegm(datetime.utcnow().utctimetuple())

        if self.jwt_generated_audience() is not None:
            payload['aud'] = self.jwt_generated_audience()

        if self.jwt_generated_audience() is not None:
            payload['iss'] = self.jwt_generated_audience()

        return payload

    def login_mutation_body(self, mutation_instance, info, *args, **kwargs):
        csrf_dec = get_csrf_rotation_decorator(self.jwt_use_csrf_rotation())
        refresh_dec = get_refresh_expiration_decorator(
            self.jwt_generated_token_expiration_time(),
            self.jwt_generated_refresh_expires_in_name()
        )
        result_func = csrf_dec(refresh_dec(super().login_mutation_body))
        result = result_func(mutation_instance, info, *args, **kwargs)
        return result

    def generate_context(self) -> any:
        return dict()


class AbstractAccessTokenGeneratorMutationCreator(AbstractTokenGeneratorMutationCreator, abc.ABC):
    """
    A generator that creates an api_token from an access_token. How the access_token is decoded is entire up to
    a custom authentication backend. This generator does not deal with it. It only deals with the generation
    of the api_token.
    In order for the api_token to be useful in authentication, another authentication backedn is required.

    In the login, the mutation requires you to input an access_token and the mutation will generate
    for you an api_token. If you use it, expects in your authentication backend an access token.

    Access token is fetch from 2 sources: from graphql login argument or from HTTP headers.

    api_token is used to gain access to all other graphql querues and mutation except the login one
    """

    def jwt_allow_argument(self) -> bool:
        """
        If set, we can fetch the token from the graphql mutaiton arguments as well.
        :return:
        """
        return True

    def jwt_auth_header_name(self) -> str:
        """
        Header where to fetch the access token
        """
        return "HTTP_AUTHORIZATION"

    def jwt_auth_heder_prefix(self):
        """
        prefix of the Authorization header where the access_token is present
        """
        return "JWT"

    def access_token(self) -> str:
        """
        name of the required token used to generate an api one
        :return:
        """
        return "access_token"

    def jwt_generated_token_name(self) -> str:
        return self.access_token()

    def api_token(self) -> str:
        return "api_token"

    def _get_authenticate_additional_fields(self, mutation_instance, info, *args, **kwargs) -> Dict[str, any]:
        """
        fetch the token from the graphql request
        """

        # fetch the token
        token = get_authenticating_token(
            request=info.context,
            jwt_auth_header_prefix=self.jwt_auth_heder_prefix(),
            token_authentication_header_name=self.jwt_auth_header_name(),
            jwt_graphql_token_argument_name=self.access_token(),
            allow_argument=self.jwt_allow_argument(),
            **kwargs
        )

        return dict(token=token)

    def _login_mutation_arguments(self, context) -> Dict[str, any]:
        return {
            self.access_token(): GraphQLHelper.argument_jwt_token(),
        }

    def me_query_arguments(self, context) -> Dict[str, any]:
        return {
            self.api_token(): GraphQLHelper.argument_jwt_token()
        }

# class ConfigAccessTokenGeneratorMutationCreator(AbstractAccessTokenGeneratorMutationCreator):
#     """
#     A creator that generates mutation and queries by looking at the configuration file.
#
#     """
#
#     def jwt_payload_name(self) -> str:
#         return settings.DJANGO_GRAPHQL_APITOKEN.JWT_PAYLOAD_NAME
#
#     def jwt_refresh_expires_in(self) -> str:
#         return settings.DJANGO_GRAPHQL_APITOKEN.JWT_REFRESH_EXPIRES_IN
#
#     def jwt_generated_token_name(self) -> str:
#         return super().jwt_generated_token_name()
#
#     def jwt_long_running_refresh_token_name(self) -> str:
#         return super().jwt_long_running_refresh_token_name()
#
#     def jwt_long_running_refresh_token(self) -> bool:
#         return super().jwt_long_running_refresh_token()
#
#     def jwt_allow_refresh(self) -> bool:
#         return super().jwt_allow_refresh()
#
#     def jwt_audience(self) -> Optional[str]:
#         return super().jwt_audience()
#
#     def jwt_issuer(self) -> Optional[str]:
#         return super().jwt_issuer()
#
#     def jwt_algorithm(self) -> str:
#         return super().jwt_algorithm()
#
#     def jwt_secret_key(self) -> str:
#         return super().jwt_secret_key()
#
#     def jwt_public_key(self) -> Optional[str]:
#         return super().jwt_public_key()
#
#     def jwt_private_key(self) -> Optional[str]:
#         return super().jwt_private_key()
#
#     def jwt_reuse_refresh_tokens(self) -> bool:
#         return super().jwt_reuse_refresh_tokens()
#
#     def jwt_refresh_token_model(self) -> type:
#         return super().jwt_refresh_token_model()
#
#     def token_expiration_time(self) -> timedelta:
#         return super().token_expiration_time()
#
#     def jwt_csrf_rotation(self) -> bool:
#         return super().jwt_csrf_rotation()
