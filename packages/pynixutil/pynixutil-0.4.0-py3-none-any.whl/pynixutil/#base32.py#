# MIT License

# Copyright (c) 2021 Tweag IO

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import base64
import ctypes
from typing import (
    List,
)


_ALPHABET = b"0123456789abcdfghijklmnpqrsvwxyz"


def uint64(i):
    return ctypes.c_ulong(int(i)).value


# EncodedLen returns the length in bytes of the base32 encoding of an input
# buffer of length n.
def _encoded_len(n: int) -> int:
    if n == 0:
        return 0
    return (n*8-1)/5 + 1


# DecodedLen returns the length in bytes of the decoded data
# corresponding to n bytes of base32-encoded data.
# If we have bits that don't fit into here, they are padding and must
# be 0.
def _decoded_len(n: int) -> int:
    return (n * 5) / 8


def b32decode(s: str, **kwargs) -> bytes:

    l = _encoded_len(len(s))

    dst = []

    n = l
    while n >= 0:
        b = uint64(n * 5)
        i = uint64(b / 8)
        j = uint64(b % 8)

        try:
            c = s[i] >> j
        except IndexError:
            raise ValueError(i)

        if i+1 < uint64(len(s)):
                c |= src[i+1] << (8 - j)

        dst.append(alphabet[c&0x1f])

        n -= 1

    return dst


def b32encode(b: bytes) -> bytes:

    # dst := make([]byte, DecodedLen(len(s)))
    # for n := 0; n < len(s); n++ {
    #         c := s[len(s)-n-1]
    #         digit := strings.IndexByte(alphabet, c)
    #         if digit == -1 {
    #                 return nil, fmt.Errorf("character %v not in alphabet!", c)
    #         }

    #         b := uint(n * 5)
    #         i := uint(b / 8)
    #         j := uint(b % 8)

    #         // OR the main pattern
    #         dst[i] |= byte(digit) << j

    #         // calculate the "carry pattern"
    #         carry := byte(digit) >> (8 - j)

    #         // if we're at the end of dstâ€¦
    #         if i == uint(len(dst)-1) {
    #                 // but have a nonzero carry, the encoding is invalid.
    #                 if carry != 0 {
    #                         return nil, fmt.Errorf("invalid encoding")
    #                 }
    #         } else {
    #                 dst[i+1] |= carry
    #         }
    # }
    # return dst, nil

    pass
