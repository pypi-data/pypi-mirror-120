# generated by datamodel-codegen:
#   filename:  wsfe.yaml

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Union

from pydantic import Extra, Field

from cognite.well_model.base_model import WellsBaseModel


class ProcessIdItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[int]


class FileType(Enum):
    las = "las"
    dlis = "dlis"
    asc = "asc"


class ProcessStatus(Enum):
    ready = "ready"
    processing = "processing"
    done = "done"
    error = "error"


class Severity(Enum):
    info = "info"
    warning = "warning"
    error = "error"


class CdfSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    file_external_id: str = Field(..., alias="fileExternalId")
    file_type: FileType = Field(..., alias="fileType")
    source: Optional[str] = Field(
        None,
        description="Original source of the data, required when using the `writeToWdl` option. Must be registered in WDL before use.",
    )


class ExternalIdMapping(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    cdf: str
    wdl: str


class Matches(WellsBaseModel):
    class Config:
        extra = Extra.allow
        allow_population_by_field_name = True

    matches: Dict[str, Matches]


class ProcessingEvent(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    timestamp: datetime
    severity: Severity
    message: str


class ExistingAsset(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well: ExternalIdMapping
    wellbore: ExternalIdMapping


class Destination(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    dataset_external_id: str = Field(..., alias="datasetExternalId")
    sequence_external_id: Optional[str] = Field(None, alias="sequenceExternalId")
    existing_asset: Optional[ExistingAsset] = Field(None, alias="existingAsset")


class CdfFileLocator(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source: CdfSource
    destination: Destination
    contains_trajectory: bool = Field(..., alias="containsTrajectory")


class ProcessingLog(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    events: List[ProcessingEvent]


class ProcessState(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    status: ProcessStatus
    project: str
    created_sequences: List[str] = Field(..., alias="createdSequences")
    created_assets: List[str] = Field(..., alias="createdAssets")
    log: ProcessingLog


class CdfFileLocatorItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    write_to_wdl: Optional[bool] = Field(None, alias="writeToWdl")
    patterns: Optional[PatternConfig] = None
    items: List[CdfFileLocator]


class Pattern(WellsBaseModel):
    __root__: Union[AnyOf, AllOf, Matches]


class AnyOf(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    any_of: List[Pattern] = Field(..., alias="anyOf")


class AllOf(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    all_of: List[Pattern] = Field(..., alias="allOf")


class PatternConfig(WellsBaseModel):
    __root__: List[MeasurementPattern]


class MeasurementPattern(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement: str
    pattern: Pattern


Matches.update_forward_refs()
CdfFileLocatorItems.update_forward_refs()
Pattern.update_forward_refs()
PatternConfig.update_forward_refs()
